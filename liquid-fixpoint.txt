-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Predicate Abstraction-based Horn-Clause/Implication Constraint Solver
--   
--   This package is a Haskell wrapper to the SMTLIB-based
--   Horn-Clause/Logical Implication constraint solver used for Liquid
--   Types.
--   
--   The package includes:
--   
--   <ol>
--   <li>Types for Expressions, Predicates, Constraints, Solutions</li>
--   <li>Code for serializing the above</li>
--   <li>Code for parsing the results from the fixpoint binary</li>
--   </ol>
--   
--   Requirements
--   
--   In addition to the .cabal dependencies you require
--   
--   <ul>
--   <li>A Z3 (<a>http://z3.codeplex.com</a>) or CVC4
--   (<a>http://cvc4.cs.nyu.edu</a>) binary. If on Windows, please make
--   sure to place the binary and any associated DLLs in your "cabal/bin"
--   folder, right next to the fixpoint.native.exe binary.</li>
--   </ul>
@package liquid-fixpoint
@version 0.6.1


-- | Progress Bar API
module Language.Fixpoint.Utils.Progress
withProgress :: Int -> IO a -> IO a
progressInit :: Int -> IO ()
progressTick :: IO ()
progressClose :: IO ()

module Language.Fixpoint.Misc
firstMaybe :: (a -> Maybe b) -> [a] -> Maybe b
asyncMapM :: (a -> IO b) -> [a] -> IO [b]
traceShow :: Show a => String -> a -> a
hashMapToAscList :: Ord a => HashMap a b -> [(a, b)]

-- | Edit Distance --------------------------------------------
editDistance :: Eq a => [a] -> [a] -> Int
data Moods
Ok :: Moods
Loud :: Moods
Sad :: Moods
Happy :: Moods
Angry :: Moods
moodColor :: Moods -> Color
wrapStars :: [Char] -> [Char]
withColor :: Color -> IO a -> IO ()
colorStrLn :: Moods -> String -> IO ()
colorPhaseLn :: Moods -> [Char] -> [Char] -> IO ()
startPhase :: Moods -> [Char] -> IO ()
doneLine :: Moods -> [Char] -> IO ()
donePhase :: Moods -> String -> IO ()
putBlankLn :: IO ()
wrap :: [a] -> [a] -> [a] -> [a]
repeats :: Int -> [a] -> [a]
errorstar :: (?callStack :: CallStack) => String -> a
fst3 :: (a, b, c) -> a
snd3 :: (a, b, c) -> b
thd3 :: (a, b, c) -> c
mlookup :: (?callStack :: CallStack, Eq k, Show k, Hashable k) => HashMap k v -> k -> v
safeLookup :: (?callStack :: CallStack, Eq k, Hashable k) => String -> k -> HashMap k v -> v
mfromJust :: (?callStack :: CallStack) => String -> Maybe a -> a
inserts :: (Eq k, Hashable k) => k -> a -> HashMap k [a] -> HashMap k [a]
group :: (Eq k, Foldable t, Hashable k) => t (k, a) -> HashMap k [a]
groupBase :: (Eq k, Foldable t, Hashable k) => HashMap k [a] -> t (k, a) -> HashMap k [a]
groupList :: (Eq k, Foldable t, Hashable k) => t (k, a) -> [(k, [a])]
groupMap :: (Eq k, Foldable t, Hashable k) => (a -> k) -> t a -> HashMap k [a]
sortNub :: (Ord a) => [a] -> [a]
safeZip :: (?callStack :: CallStack) => String -> [a] -> [b] -> [(a, b)]
safeZipWith :: (?callStack :: CallStack) => String -> (a -> b -> c) -> [a] -> [b] -> [c]
type ListNE a = [a]
safeHead :: (?callStack :: CallStack) => String -> ListNE a -> a
safeLast :: (?callStack :: CallStack) => String -> ListNE a -> a
safeInit :: (?callStack :: CallStack) => String -> ListNE a -> [a]
safeUncons :: (?callStack :: CallStack) => String -> ListNE a -> (a, [a])
safeUnsnoc :: (?callStack :: CallStack) => String -> ListNE a -> ([a], a)
executeShellCommand :: [Char] -> [Char] -> IO ExitCode
applyNonNull :: t -> ([t1] -> t) -> [t1] -> t
arrow :: Doc
dcolon :: Doc
intersperse :: Doc -> [Doc] -> Doc
tshow :: Show a => a -> Doc

-- | if loud, write a string to stdout
writeLoud :: String -> IO ()
ensurePath :: FilePath -> IO ()
fM :: (Monad m) => (a -> b) -> a -> m b


-- | This module contains Haskell variables representing globally visible
--   names for files, paths, extensions.
--   
--   Rather than have strings floating around the system, all constant
--   names should be defined here, and the (exported) variables should be
--   used and manipulated elsewhere.
module Language.Fixpoint.Utils.Files
data Ext

-- | Constraint Generation Information
Cgi :: Ext

-- | Input to constraint solving (fixpoint)
Fq :: Ext

-- | Output from constraint solving (fixpoint)
Out :: Ext

-- | HTML file with inferred type annotations
Html :: Ext

-- | Text file with inferred types
Annot :: Ext

-- | Vim annotation file
Vim :: Ext

-- | Haskell source
Hs :: Ext

-- | Haskell source
HsBoot :: Ext

-- | Literate Haskell source
LHs :: Ext

-- | JavaScript source
Js :: Ext

-- | Typescript source
Ts :: Ext

-- | Spec file (e.g. include/Prelude.spec)
Spec :: Ext

-- | Qualifiers file (e.g. include/Prelude.hquals)
Hquals :: Ext

-- | Final result: SAFE/UNSAFE
Result :: Ext

-- | HTML file with templates?
Cst :: Ext

-- | Markdown file (temporarily generated from .Lhs + annots)
Mkdn :: Ext

-- | JSON file containing result (annots + errors)
Json :: Ext

-- | Previous source (for incremental checking)
Saved :: Ext

-- | Previous output (for incremental checking)
Cache :: Ext

-- | Constraint Graph
Dot :: Ext

-- | Partition
Part :: Int -> Ext

-- | SMTLIB2 queries for automatically created proofs
Auto :: Int -> Ext
Pred :: Ext
PAss :: Ext
Dat :: Ext

-- | Binary representation of .fq / FInfo
BinFq :: Ext

-- | SMTLIB2 query file
Smt2 :: Ext

-- | filter constraints with delta debug
Min :: Ext
extFileName :: Ext -> FilePath -> FilePath
extFileNameR :: Ext -> FilePath -> FilePath
tempDirectory :: FilePath -> FilePath
extModuleName :: String -> Ext -> FilePath
withExt :: FilePath -> Ext -> FilePath
isExtFile :: Ext -> FilePath -> Bool

-- | Hardwired Paths and Files -----------------------------
getFixpointPath :: IO FilePath
getZ3LibPath :: IO FilePath
getFileInDirs :: FilePath -> [FilePath] -> IO (Maybe FilePath)
copyFiles :: [FilePath] -> FilePath -> IO ()
instance GHC.Show.Show Language.Fixpoint.Utils.Files.Ext
instance GHC.Classes.Ord Language.Fixpoint.Utils.Files.Ext
instance GHC.Classes.Eq Language.Fixpoint.Utils.Files.Ext

module Language.Fixpoint.Types.Config
data Config
Config :: FilePath -> FilePath -> FilePath -> Maybe Int -> Int -> Int -> SMTSolver -> GenQualifierSort -> UeqAllSorts -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Config

-- | target fq-file
[inFile] :: Config -> FilePath

-- | output file
[outFile] :: Config -> FilePath

-- | src file (*.hs, *.ts, *.c)
[srcFile] :: Config -> FilePath

-- | number of cores used to solve constraints
[cores] :: Config -> Maybe Int

-- | Minimum size of a partition
[minPartSize] :: Config -> Int

-- | Maximum size of a partition. Overrides minPartSize
[maxPartSize] :: Config -> Int

-- | which SMT solver to use
[solver] :: Config -> SMTSolver

-- | generalize qualifier sorts
[genSorts] :: Config -> GenQualifierSort

-- | use UEq on all sorts
[ueqAllSorts] :: Config -> UeqAllSorts

-- | interpret div and mul in SMT
[real] :: Config -> Bool

-- | new fixpoint sort check
[newcheck] :: Config -> Bool

-- | eliminate non-cut KVars
[eliminate] :: Config -> Bool

-- | print eliminate stats
[elimStats] :: Config -> Bool

-- | print meta-data associated with constraints
[metadata] :: Config -> Bool

-- | compute constraint statistics
[stats] :: Config -> Bool

-- | partition FInfo into separate fq files
[parts] :: Config -> Bool

-- | save FInfo as .bfq and .fq file
[save] :: Config -> Bool

-- | use delta debug to min fq file , nontriv :: Bool -- ^ simplify using
--   non-trivial sorts
[minimize] :: Config -> Bool
getOpts :: IO Config
class Command a
command :: Command a => a -> String
data SMTSolver
Z3 :: SMTSolver
Cvc4 :: SMTSolver
Mathsat :: SMTSolver
newtype GenQualifierSort
GQS :: Bool -> GenQualifierSort
newtype UeqAllSorts
UAS :: Bool -> UeqAllSorts
withTarget :: Config -> FilePath -> Config
defaultMinPartSize :: Int
defaultMaxPartSize :: Int
multicore :: Config -> Bool
instance GHC.Generics.Constructor Language.Fixpoint.Types.Config.C1_2SMTSolver
instance GHC.Generics.Constructor Language.Fixpoint.Types.Config.C1_1SMTSolver
instance GHC.Generics.Constructor Language.Fixpoint.Types.Config.C1_0SMTSolver
instance GHC.Generics.Datatype Language.Fixpoint.Types.Config.D1SMTSolver
instance GHC.Show.Show Language.Fixpoint.Types.Config.Config
instance Data.Data.Data Language.Fixpoint.Types.Config.Config
instance GHC.Classes.Eq Language.Fixpoint.Types.Config.Config
instance GHC.Generics.Generic Language.Fixpoint.Types.Config.SMTSolver
instance Data.Data.Data Language.Fixpoint.Types.Config.SMTSolver
instance GHC.Classes.Eq Language.Fixpoint.Types.Config.SMTSolver
instance GHC.Show.Show Language.Fixpoint.Types.Config.UeqAllSorts
instance Data.Data.Data Language.Fixpoint.Types.Config.UeqAllSorts
instance GHC.Classes.Eq Language.Fixpoint.Types.Config.UeqAllSorts
instance GHC.Show.Show Language.Fixpoint.Types.Config.GenQualifierSort
instance Data.Data.Data Language.Fixpoint.Types.Config.GenQualifierSort
instance GHC.Classes.Eq Language.Fixpoint.Types.Config.GenQualifierSort
instance System.Console.CmdArgs.Default.Default Language.Fixpoint.Types.Config.Config
instance Language.Fixpoint.Types.Config.Command Language.Fixpoint.Types.Config.Config
instance System.Console.CmdArgs.Default.Default Language.Fixpoint.Types.Config.GenQualifierSort
instance Language.Fixpoint.Types.Config.Command Language.Fixpoint.Types.Config.GenQualifierSort
instance System.Console.CmdArgs.Default.Default Language.Fixpoint.Types.Config.UeqAllSorts
instance Language.Fixpoint.Types.Config.Command Language.Fixpoint.Types.Config.UeqAllSorts
instance Language.Fixpoint.Types.Config.Command Language.Fixpoint.Types.Config.SMTSolver
instance System.Console.CmdArgs.Default.Default Language.Fixpoint.Types.Config.SMTSolver
instance GHC.Show.Show Language.Fixpoint.Types.Config.SMTSolver

module Language.Fixpoint.Types.PrettyPrint
traceFix :: (Fixpoint a) => String -> a -> a
class Fixpoint a where simplify = id
toFix :: Fixpoint a => a -> Doc
simplify :: Fixpoint a => a -> a
showFix :: (Fixpoint a) => a -> String
data Tidy
Lossy :: Tidy
Full :: Tidy
class PPrint a where pprint = pprintPrec 0 pprintPrec _ = pprint pprintTidy _ = pprint
pprint :: PPrint a => a -> Doc

-- | Pretty-print something with a specific precedence.
pprintPrec :: PPrint a => Int -> a -> Doc
pprintTidy :: PPrint a => Tidy -> a -> Doc
showpp :: (PPrint a) => a -> String
tracepp :: (PPrint a) => String -> a -> a
pprintKVs :: (PPrint k, PPrint v) => [(k, v)] -> Doc
newtype DocTable
DocTable :: [(Doc, Doc)] -> DocTable
class PTable a
ptable :: PTable a => a -> DocTable
boxHSep :: Doc -> Doc -> Doc
boxDoc :: Box -> Doc
docBox :: Doc -> Box
instance GHC.Classes.Ord Language.Fixpoint.Types.PrettyPrint.Tidy
instance GHC.Classes.Eq Language.Fixpoint.Types.PrettyPrint.Tidy
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a, Language.Fixpoint.Types.PrettyPrint.Fixpoint a) => Language.Fixpoint.Types.PrettyPrint.Fixpoint (Data.HashSet.HashSet a)
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint ()
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint a => Language.Fixpoint.Types.PrettyPrint.Fixpoint (GHC.Base.Maybe a)
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint a => Language.Fixpoint.Types.PrettyPrint.Fixpoint [a]
instance (Language.Fixpoint.Types.PrettyPrint.Fixpoint a, Language.Fixpoint.Types.PrettyPrint.Fixpoint b) => Language.Fixpoint.Types.PrettyPrint.Fixpoint (a, b)
instance (Language.Fixpoint.Types.PrettyPrint.Fixpoint a, Language.Fixpoint.Types.PrettyPrint.Fixpoint b, Language.Fixpoint.Types.PrettyPrint.Fixpoint c) => Language.Fixpoint.Types.PrettyPrint.Fixpoint (a, b, c)
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint GHC.Types.Bool
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint GHC.Types.Int
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint GHC.Integer.Type.Integer
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint GHC.Types.Double
instance Language.Fixpoint.Types.PrettyPrint.PPrint Text.PrettyPrint.HughesPJ.Doc
instance Language.Fixpoint.Types.PrettyPrint.PPrint a => Language.Fixpoint.Types.PrettyPrint.PPrint (GHC.Base.Maybe a)
instance Language.Fixpoint.Types.PrettyPrint.PPrint a => Language.Fixpoint.Types.PrettyPrint.PPrint [a]
instance Language.Fixpoint.Types.PrettyPrint.PPrint a => Language.Fixpoint.Types.PrettyPrint.PPrint (Data.HashSet.HashSet a)
instance (Language.Fixpoint.Types.PrettyPrint.PPrint a, Language.Fixpoint.Types.PrettyPrint.PPrint b) => Language.Fixpoint.Types.PrettyPrint.PPrint (Data.HashMap.Base.HashMap a b)
instance (Language.Fixpoint.Types.PrettyPrint.PPrint a, Language.Fixpoint.Types.PrettyPrint.PPrint b, Language.Fixpoint.Types.PrettyPrint.PPrint c) => Language.Fixpoint.Types.PrettyPrint.PPrint (a, b, c)
instance (Language.Fixpoint.Types.PrettyPrint.PPrint a, Language.Fixpoint.Types.PrettyPrint.PPrint b) => Language.Fixpoint.Types.PrettyPrint.PPrint (a, b)
instance Language.Fixpoint.Types.PrettyPrint.PPrint GHC.Types.Bool
instance Language.Fixpoint.Types.PrettyPrint.PPrint GHC.Types.Float
instance Language.Fixpoint.Types.PrettyPrint.PPrint ()
instance Language.Fixpoint.Types.PrettyPrint.PPrint GHC.Base.String
instance Language.Fixpoint.Types.PrettyPrint.PPrint GHC.Types.Int
instance Language.Fixpoint.Types.PrettyPrint.PPrint GHC.Integer.Type.Integer
instance Language.Fixpoint.Types.PrettyPrint.PPrint Data.Text.Internal.Text
instance GHC.Base.Monoid Language.Fixpoint.Types.PrettyPrint.DocTable
instance Language.Fixpoint.Types.PrettyPrint.PPrint Language.Fixpoint.Types.PrettyPrint.DocTable

module Language.Fixpoint.Types.Spans

-- | The abstract data type <tt>SourcePos</tt> represents source positions.
--   It contains the name of the source (i.e. file name), a line number and
--   a column number. <tt>SourcePos</tt> is an instance of the <a>Show</a>,
--   <a>Eq</a> and <a>Ord</a> class.
data SourcePos :: *

-- | A Reusable SrcSpan Type ------------------------------------------
data SrcSpan
SS :: !SourcePos -> !SourcePos -> SrcSpan
[sp_start] :: SrcSpan -> !SourcePos
[sp_stop] :: SrcSpan -> !SourcePos

-- | Located Values ---------------------------------------------------
class Loc a
srcSpan :: Loc a => a -> SrcSpan
data Located a
Loc :: !SourcePos -> !SourcePos -> a -> Located a

-- | Start Position
[loc] :: Located a -> !SourcePos

-- | End Position
[locE] :: Located a -> !SourcePos
[val] :: Located a -> a
dummySpan :: SrcSpan
locAt :: String -> a -> Located a
dummyLoc :: a -> Located a
dummyPos :: String -> SourcePos
sourcePosElts :: SourcePos -> (SourceName, Line, Column)
instance GHC.Generics.Selector Language.Fixpoint.Types.Spans.S1_0_1SrcSpan
instance GHC.Generics.Selector Language.Fixpoint.Types.Spans.S1_0_0SrcSpan
instance GHC.Generics.Constructor Language.Fixpoint.Types.Spans.C1_0SrcSpan
instance GHC.Generics.Datatype Language.Fixpoint.Types.Spans.D1SrcSpan
instance GHC.Generics.Selector Language.Fixpoint.Types.Spans.S1_0_2Located
instance GHC.Generics.Selector Language.Fixpoint.Types.Spans.S1_0_1Located
instance GHC.Generics.Selector Language.Fixpoint.Types.Spans.S1_0_0Located
instance GHC.Generics.Constructor Language.Fixpoint.Types.Spans.C1_0Located
instance GHC.Generics.Datatype Language.Fixpoint.Types.Spans.D1Located
instance GHC.Generics.Generic Language.Fixpoint.Types.Spans.SrcSpan
instance Data.Data.Data Language.Fixpoint.Types.Spans.SrcSpan
instance GHC.Show.Show Language.Fixpoint.Types.Spans.SrcSpan
instance GHC.Classes.Ord Language.Fixpoint.Types.Spans.SrcSpan
instance GHC.Classes.Eq Language.Fixpoint.Types.Spans.SrcSpan
instance GHC.Generics.Generic (Language.Fixpoint.Types.Spans.Located a)
instance Data.Data.Data a => Data.Data.Data (Language.Fixpoint.Types.Spans.Located a)
instance Control.DeepSeq.NFData Text.Parsec.Pos.SourcePos
instance Data.Binary.Class.Binary Text.Parsec.Pos.SourcePos
instance Data.Serialize.Serialize Text.Parsec.Pos.SourcePos
instance Language.Fixpoint.Types.PrettyPrint.PPrint Text.Parsec.Pos.SourcePos
instance Data.Hashable.Class.Hashable Text.Parsec.Pos.SourcePos
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Text.Parsec.Pos.SourcePos
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Language.Fixpoint.Types.Spans.Located a)
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint a => Language.Fixpoint.Types.PrettyPrint.Fixpoint (Language.Fixpoint.Types.Spans.Located a)
instance GHC.Base.Functor Language.Fixpoint.Types.Spans.Located
instance Data.Foldable.Foldable Language.Fixpoint.Types.Spans.Located
instance Data.Traversable.Traversable Language.Fixpoint.Types.Spans.Located
instance GHC.Show.Show a => GHC.Show.Show (Language.Fixpoint.Types.Spans.Located a)
instance Language.Fixpoint.Types.PrettyPrint.PPrint a => Language.Fixpoint.Types.PrettyPrint.PPrint (Language.Fixpoint.Types.Spans.Located a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Fixpoint.Types.Spans.Located a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.Fixpoint.Types.Spans.Located a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Language.Fixpoint.Types.Spans.Located a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Language.Fixpoint.Types.Spans.Located a)
instance Data.String.IsString a => Data.String.IsString (Language.Fixpoint.Types.Spans.Located a)
instance Data.Serialize.Serialize Language.Fixpoint.Types.Spans.SrcSpan
instance Language.Fixpoint.Types.PrettyPrint.PPrint Language.Fixpoint.Types.Spans.SrcSpan
instance Data.Hashable.Class.Hashable Language.Fixpoint.Types.Spans.SrcSpan

module Language.Fixpoint.Types.Errors

-- | A Reusable SrcSpan Type ------------------------------------------
data SrcSpan
SS :: !SourcePos -> !SourcePos -> SrcSpan
[sp_start] :: SrcSpan -> !SourcePos
[sp_stop] :: SrcSpan -> !SourcePos
dummySpan :: SrcSpan
sourcePosElts :: SourcePos -> (SourceName, Line, Column)

-- | Result ---------------------------------------------------------
data FixResult a
Crash :: [a] -> String -> FixResult a
Safe :: FixResult a
Unsafe :: ![a] -> FixResult a
colorResult :: FixResult a -> Moods
resultDoc :: (Fixpoint a) => FixResult a -> Doc

-- | A BareBones Error Type -------------------------------------------
data Error
err :: SrcSpan -> String -> Error
errLoc :: Error -> SrcSpan
errMsg :: Error -> String
catMessage :: Error -> String -> Error
catError :: Error -> Error -> Error
catErrors :: ListNE Error -> Error
die :: Error -> a
exit :: a -> IO a -> IO a

-- | Catalogue of Errors --------------------------------------------
errFreeVarInQual :: (Fixpoint a, Loc a) => a -> Error
instance GHC.Generics.Constructor Language.Fixpoint.Types.Errors.C1_2FixResult
instance GHC.Generics.Constructor Language.Fixpoint.Types.Errors.C1_1FixResult
instance GHC.Generics.Constructor Language.Fixpoint.Types.Errors.C1_0FixResult
instance GHC.Generics.Datatype Language.Fixpoint.Types.Errors.D1FixResult
instance GHC.Generics.Selector Language.Fixpoint.Types.Errors.S1_0_1Error
instance GHC.Generics.Selector Language.Fixpoint.Types.Errors.S1_0_0Error
instance GHC.Generics.Constructor Language.Fixpoint.Types.Errors.C1_0Error
instance GHC.Generics.Datatype Language.Fixpoint.Types.Errors.D1Error
instance GHC.Generics.Generic (Language.Fixpoint.Types.Errors.FixResult a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Fixpoint.Types.Errors.FixResult a)
instance Data.Traversable.Traversable Language.Fixpoint.Types.Errors.FixResult
instance Data.Foldable.Foldable Language.Fixpoint.Types.Errors.FixResult
instance Data.Data.Data a => Data.Data.Data (Language.Fixpoint.Types.Errors.FixResult a)
instance GHC.Generics.Generic Language.Fixpoint.Types.Errors.Error
instance Data.Data.Data Language.Fixpoint.Types.Errors.Error
instance GHC.Show.Show Language.Fixpoint.Types.Errors.Error
instance GHC.Classes.Ord Language.Fixpoint.Types.Errors.Error
instance GHC.Classes.Eq Language.Fixpoint.Types.Errors.Error
instance Data.Serialize.Serialize Language.Fixpoint.Types.Errors.Error
instance Data.Serialize.Serialize (Language.Fixpoint.Types.Errors.FixResult Language.Fixpoint.Types.Errors.Error)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Language.Fixpoint.Types.Errors.FixResult a)
instance Language.Fixpoint.Types.PrettyPrint.PPrint Language.Fixpoint.Types.Errors.Error
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Language.Fixpoint.Types.Errors.Error
instance GHC.Exception.Exception Language.Fixpoint.Types.Errors.Error
instance GHC.Exception.Exception (Language.Fixpoint.Types.Errors.FixResult Language.Fixpoint.Types.Errors.Error)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Language.Fixpoint.Types.Errors.FixResult a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Fixpoint.Types.Errors.FixResult a)
instance GHC.Base.Monoid (Language.Fixpoint.Types.Errors.FixResult a)
instance GHC.Base.Functor Language.Fixpoint.Types.Errors.FixResult


-- | This module contains Haskell variables representing globally visible
--   names. Rather than have strings floating around the system, all
--   constant names should be defined here, and the (exported) variables
--   should be used and manipulated elsewhere.
module Language.Fixpoint.Types.Names

-- | Invariant: a <a>SafeText</a> is made up of:
--   
--   <ul>
--   <li><i>'0'..'9'</i> ++ ['a'...'z'] ++ ['A'..'Z'] ++ <a>$</a></li>
--   </ul>
--   
--   If the original text has ANY other chars, it is represented as:
--   
--   lq$i
--   
--   where i is a unique integer (for each text)
data Symbol

-- | Values that can be viewed as Symbols
class Symbolic a
symbol :: Symbolic a => a -> Symbol

-- | Located Symbols -----------------------------------------------------
type LocSymbol = Located Symbol
type LocText = Located Text
symbolSafeText :: Symbol -> SafeText
symbolSafeString :: Symbol -> String

-- | Decoding Symbols -----------------------------------------------------
symbolText :: Symbol -> Text
symbolString :: Symbol -> String
isPrefixOfSym :: Symbol -> Symbol -> Bool
isSuffixOfSym :: Symbol -> Symbol -> Bool
isNonSymbol :: Symbol -> Bool
isNontrivialVV :: Symbol -> Bool
isDummy :: (Symbolic a) => a -> Bool
stripPrefix :: Symbol -> Symbol -> Maybe Symbol
consSym :: Char -> Symbol -> Symbol
unconsSym :: Symbol -> Maybe (Char, Symbol)
dropSym :: Int -> Symbol -> Symbol
headSym :: Symbol -> Char
lengthSym :: Symbol -> Int
nonSymbol :: Symbol
vvCon :: Symbol
tidySymbol :: Symbol -> Symbol
anfPrefix :: Symbol
tempPrefix :: Symbol
vv :: Maybe Integer -> Symbol
symChars :: HashSet Char
dummySymbol :: Symbol
intSymbol :: (Show a) => Symbol -> a -> Symbol
tempSymbol :: Symbol -> Integer -> Symbol
litSymbol :: Symbol -> Symbol
renameSymbol :: Symbol -> Int -> Symbol
kArgSymbol :: Symbol -> Symbol -> Symbol
existSymbol :: Symbol -> Integer -> Symbol

-- | Use this **EXCLUSIVELY** when you want to add stuff in front of a
--   Symbol
suffixSymbol :: Symbol -> Symbol -> Symbol
unLitSymbol :: Symbol -> Maybe Symbol
dummyName :: Symbol
preludeName :: Symbol
boolConName :: Symbol
funConName :: Symbol
listConName :: Symbol
listLConName :: Symbol
tupConName :: Symbol
propConName :: Symbol
hpropConName :: Symbol
strConName :: Symbol
nilName :: Symbol
consName :: Symbol
vvName :: Symbol
size32Name :: Symbol
size64Name :: Symbol
bitVecName :: Symbol
bvAndName :: Symbol
bvOrName :: Symbol
prims :: [Symbol]
mulFuncName :: Symbol
divFuncName :: Symbol
instance GHC.Generics.Selector Language.Fixpoint.Types.Names.S1_0_1InternedText
instance GHC.Generics.Selector Language.Fixpoint.Types.Names.S1_0_0InternedText
instance GHC.Generics.Constructor Language.Fixpoint.Types.Names.C1_0InternedText
instance GHC.Generics.Datatype Language.Fixpoint.Types.Names.D1InternedText
instance GHC.Generics.Selector Language.Fixpoint.Types.Names.S1_0_2Symbol
instance GHC.Generics.Selector Language.Fixpoint.Types.Names.S1_0_1Symbol
instance GHC.Generics.Selector Language.Fixpoint.Types.Names.S1_0_0Symbol
instance GHC.Generics.Constructor Language.Fixpoint.Types.Names.C1_0Symbol
instance GHC.Generics.Datatype Language.Fixpoint.Types.Names.D1Symbol
instance GHC.Classes.Eq (Data.Interned.Internal.Description Language.Fixpoint.Types.Names.Symbol)
instance GHC.Generics.Generic Language.Fixpoint.Types.Names.Symbol
instance Data.Data.Data Language.Fixpoint.Types.Names.Symbol
instance Data.Data.Data Data.Interned.Internal.Text.InternedText
instance GHC.Generics.Generic Data.Interned.Internal.Text.InternedText
instance GHC.Classes.Eq Language.Fixpoint.Types.Names.Symbol
instance GHC.Classes.Ord Language.Fixpoint.Types.Names.Symbol
instance Data.Interned.Internal.Interned Language.Fixpoint.Types.Names.Symbol
instance Data.Interned.Internal.Uninternable Language.Fixpoint.Types.Names.Symbol
instance Data.Hashable.Class.Hashable (Data.Interned.Internal.Description Language.Fixpoint.Types.Names.Symbol)
instance Data.Hashable.Class.Hashable Language.Fixpoint.Types.Names.Symbol
instance Control.DeepSeq.NFData Language.Fixpoint.Types.Names.Symbol
instance Data.Binary.Class.Binary Language.Fixpoint.Types.Names.Symbol
instance Data.String.IsString Language.Fixpoint.Types.Names.Symbol
instance GHC.Show.Show Language.Fixpoint.Types.Names.Symbol
instance Language.Fixpoint.Types.PrettyPrint.PPrint Language.Fixpoint.Types.Names.Symbol
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Data.Text.Internal.Text
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Language.Fixpoint.Types.Names.Symbol
instance Language.Fixpoint.Types.Names.Symbolic a => Language.Fixpoint.Types.Names.Symbolic (Language.Fixpoint.Types.Spans.Located a)
instance Language.Fixpoint.Types.Names.Symbolic Data.Text.Internal.Text
instance Language.Fixpoint.Types.Names.Symbolic GHC.Base.String
instance Language.Fixpoint.Types.Names.Symbolic Language.Fixpoint.Types.Names.Symbol


-- | This module contains the data types, operations and serialization
--   functions for representing Fixpoint's implication (i.e. subtyping) and
--   well-formedness constraints in Haskell. The actual constraint solving
--   is done by the `fixpoint.native` which is written in Ocaml.
module Language.Fixpoint.Types.Sorts
data Sort
FInt :: Sort
FReal :: Sort

-- | numeric kind for Num tyvars
FNum :: Sort

-- | numeric kind for Fractional tyvars
FFrac :: Sort

-- | uninterpreted type
FObj :: Symbol -> Sort

-- | fixpoint type variable
FVar :: !Int -> Sort

-- | type-var arity, in-ts ++ [out-t]
FFunc :: !Int -> ![Sort] -> Sort
FTC :: FTycon -> Sort

-- | constructed type
FApp :: Sort -> Sort -> Sort
newtype Sub
Sub :: [(Int, Sort)] -> Sub
data FTycon
type TCEmb a = HashMap a FTycon
sortFTycon :: Sort -> Maybe FTycon
intFTyCon :: FTycon
boolFTyCon :: FTycon
realFTyCon :: FTycon
numFTyCon :: FTycon

-- | Exported Basic Sorts -----------------------------------------------
intSort :: Sort

-- | Exported Basic Sorts -----------------------------------------------
realSort :: Sort

-- | Exported Basic Sorts -----------------------------------------------
boolSort :: Sort

-- | Exported Basic Sorts -----------------------------------------------
strSort :: Sort

-- | Exported Basic Sorts -----------------------------------------------
funcSort :: Sort
listFTyCon :: FTycon
isListTC :: FTycon -> Bool
fTyconSymbol :: FTycon -> Located Symbol
symbolFTycon :: LocSymbol -> FTycon
fTyconSort :: FTycon -> Sort
fApp :: Sort -> [Sort] -> Sort
fApp' :: Sort -> ListNE Sort
fAppTC :: FTycon -> [Sort] -> Sort
fObj :: LocSymbol -> Sort
sortSubst :: HashMap Symbol Sort -> Sort -> Sort
functionSort :: Sort -> Maybe (Int, [Sort], Sort)
instance GHC.Generics.Constructor Language.Fixpoint.Types.Sorts.C1_0Sub
instance GHC.Generics.Datatype Language.Fixpoint.Types.Sorts.D1Sub
instance GHC.Generics.Constructor Language.Fixpoint.Types.Sorts.C1_8Sort
instance GHC.Generics.Constructor Language.Fixpoint.Types.Sorts.C1_7Sort
instance GHC.Generics.Constructor Language.Fixpoint.Types.Sorts.C1_6Sort
instance GHC.Generics.Constructor Language.Fixpoint.Types.Sorts.C1_5Sort
instance GHC.Generics.Constructor Language.Fixpoint.Types.Sorts.C1_4Sort
instance GHC.Generics.Constructor Language.Fixpoint.Types.Sorts.C1_3Sort
instance GHC.Generics.Constructor Language.Fixpoint.Types.Sorts.C1_2Sort
instance GHC.Generics.Constructor Language.Fixpoint.Types.Sorts.C1_1Sort
instance GHC.Generics.Constructor Language.Fixpoint.Types.Sorts.C1_0Sort
instance GHC.Generics.Datatype Language.Fixpoint.Types.Sorts.D1Sort
instance GHC.Generics.Constructor Language.Fixpoint.Types.Sorts.C1_0FTycon
instance GHC.Generics.Datatype Language.Fixpoint.Types.Sorts.D1FTycon
instance GHC.Generics.Generic Language.Fixpoint.Types.Sorts.Sub
instance GHC.Generics.Generic Language.Fixpoint.Types.Sorts.Sort
instance Data.Data.Data Language.Fixpoint.Types.Sorts.Sort
instance GHC.Show.Show Language.Fixpoint.Types.Sorts.Sort
instance GHC.Classes.Ord Language.Fixpoint.Types.Sorts.Sort
instance GHC.Classes.Eq Language.Fixpoint.Types.Sorts.Sort
instance GHC.Generics.Generic Language.Fixpoint.Types.Sorts.FTycon
instance Data.Data.Data Language.Fixpoint.Types.Sorts.FTycon
instance GHC.Show.Show Language.Fixpoint.Types.Sorts.FTycon
instance GHC.Classes.Ord Language.Fixpoint.Types.Sorts.FTycon
instance GHC.Classes.Eq Language.Fixpoint.Types.Sorts.FTycon
instance Data.Hashable.Class.Hashable Language.Fixpoint.Types.Sorts.FTycon
instance Data.Hashable.Class.Hashable Language.Fixpoint.Types.Sorts.Sort
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Language.Fixpoint.Types.Sorts.Sort
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Language.Fixpoint.Types.Sorts.FTycon
instance Data.Binary.Class.Binary Language.Fixpoint.Types.Sorts.FTycon
instance Data.Binary.Class.Binary Language.Fixpoint.Types.Sorts.Sort
instance Data.Binary.Class.Binary Language.Fixpoint.Types.Sorts.Sub
instance Control.DeepSeq.NFData Language.Fixpoint.Types.Sorts.FTycon
instance Control.DeepSeq.NFData Language.Fixpoint.Types.Sorts.Sort
instance Control.DeepSeq.NFData Language.Fixpoint.Types.Sorts.Sub
instance GHC.Base.Monoid Language.Fixpoint.Types.Sorts.Sort


-- | This module contains the data types for representing terms in the
--   refinement logic; currently split into <tt>Expr</tt> and <tt>Pred</tt>
--   but which will be unified.
module Language.Fixpoint.Types.Refinements

-- | Expressions
--   ---------------------------------------------------------------
--   
--   Uninterpreted constants that are embedded as "constant symbol : Str"
data SymConst
SL :: !Text -> SymConst
data Constant
I :: !Integer -> Constant
R :: !Double -> Constant
L :: !Text -> !Sort -> Constant
data Bop
Plus :: Bop
Minus :: Bop
Times :: Bop
Div :: Bop
Mod :: Bop
data Brel
Eq :: Brel
Ne :: Brel
Gt :: Brel
Ge :: Brel
Lt :: Brel
Le :: Brel
Ueq :: Brel
Une :: Brel
data Expr
ESym :: !SymConst -> Expr
ECon :: !Constant -> Expr
EVar :: !Symbol -> Expr
EApp :: !LocSymbol -> ![Expr] -> Expr
ENeg :: !Expr -> Expr
EBin :: !Bop -> !Expr -> !Expr -> Expr
EIte :: !Expr -> !Expr -> !Expr -> Expr
ECst :: !Expr -> !Sort -> Expr
EBot :: Expr
ETApp :: !Expr -> !Sort -> Expr
ETAbs :: !Expr -> !Symbol -> Expr
PTrue :: Expr
PFalse :: Expr
PAnd :: !(ListNE Expr) -> Expr
POr :: ![Expr] -> Expr
PNot :: !Expr -> Expr
PImp :: !Expr -> !Expr -> Expr
PIff :: !Expr -> !Expr -> Expr
PAtom :: !Brel -> !Expr -> !Expr -> Expr
PKVar :: !KVar -> !Subst -> Expr
PAll :: ![(Symbol, Sort)] -> !Expr -> Expr
PExist :: ![(Symbol, Sort)] -> !Expr -> Expr
PTop :: Expr

-- | Kvars
--   ---------------------------------------------------------------------
newtype KVar
KV :: Symbol -> KVar
[kv] :: KVar -> Symbol

-- | Substitutions
--   -------------------------------------------------------------
newtype Subst
Su :: (HashMap Symbol Expr) -> Subst
newtype Reft
Reft :: (Symbol, Expr) -> Reft
data SortedReft
RR :: !Sort -> !Reft -> SortedReft
[sr_sort] :: SortedReft -> !Sort
[sr_reft] :: SortedReft -> !Reft
eVar :: Symbolic a => a -> Expr
elit :: Located Symbol -> Sort -> Expr
eProp :: Symbolic a => a -> Expr
pAnd :: ListNE Expr -> Expr
pOr :: ListNE Expr -> Expr
pIte :: Expr -> Expr -> Expr -> Expr
isTautoPred :: Expr -> Bool

-- | Generalizing Symbol, Expression, Predicate into Classes -----------
--   
--   Values that can be viewed as Constants
--   
--   Values that can be viewed as Expressions
class Expression a
expr :: Expression a => a -> Expr

-- | Values that can be viewed as Predicates
class Predicate a
prop :: Predicate a => a -> Expr

-- | Class Predicates for Valid Refinements -----------------------------
class Subable a where subst1 y (x, e) = subst (Su $ fromList [(x, e)]) y
syms :: Subable a => a -> [Symbol]
substa :: Subable a => (Symbol -> Symbol) -> a -> a
substf :: Subable a => (Symbol -> Expr) -> a -> a
subst :: Subable a => Subst -> a -> a
subst1 :: Subable a => a -> (Symbol, Expr) -> a
class (Monoid r, Subable r) => Reftable r where top _ = mempty meet = mappend
isTauto :: Reftable r => r -> Bool
ppTy :: Reftable r => r -> Doc -> Doc
top :: Reftable r => r -> r
bot :: Reftable r => r -> r
meet :: Reftable r => r -> r -> r
toReft :: Reftable r => r -> Reft
ofReft :: Reftable r => Reft -> r
params :: Reftable r => r -> [Symbol]
reft :: Symbol -> Expr -> Reft
trueSortedReft :: Sort -> SortedReft
trueReft :: Reft
falseReft :: Reft
exprReft :: (Expression a) => a -> Reft
notExprReft :: (Expression a) => a -> Reft
uexprReft :: (Expression a) => a -> Reft

-- | Generally Useful Refinements --------------------------
symbolReft :: (Symbolic a) => a -> Reft
usymbolReft :: (Symbolic a) => a -> Reft
propReft :: (Predicate a) => a -> Reft
predReft :: (Predicate a) => a -> Reft
reftPred :: Reft -> Expr
reftBind :: Reft -> Symbol

-- | Refinements ----------------------------------------------
isFunctionSortedReft :: SortedReft -> Bool
functionSort :: Sort -> Maybe (Int, [Sort], Sort)
isNonTrivial :: Reftable r => r -> Bool

-- | Predicates
--   ----------------------------------------------------------------
isSingletonReft :: Reft -> Maybe Expr
isEVar :: Expr -> Bool
isFalse :: Falseable a => a -> Bool
flattenRefas :: [Expr] -> [Expr]
conjuncts :: Expr -> [Expr]
mapPredReft :: (Expr -> Expr) -> Reft -> Reft
pprintReft :: Reft -> Doc
reftConjuncts :: Reft -> [Reft]
intKvar :: Integer -> KVar
vv_ :: Symbol
instance GHC.Generics.Selector Language.Fixpoint.Types.Refinements.S1_0_1SortedReft
instance GHC.Generics.Selector Language.Fixpoint.Types.Refinements.S1_0_0SortedReft
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_0SortedReft
instance GHC.Generics.Datatype Language.Fixpoint.Types.Refinements.D1SortedReft
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_0Reft
instance GHC.Generics.Datatype Language.Fixpoint.Types.Refinements.D1Reft
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_0Subst
instance GHC.Generics.Datatype Language.Fixpoint.Types.Refinements.D1Subst
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_22Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_21Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_20Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_19Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_18Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_17Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_16Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_15Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_14Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_13Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_12Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_11Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_10Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_9Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_8Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_7Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_6Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_5Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_4Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_3Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_2Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_1Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_0Expr
instance GHC.Generics.Datatype Language.Fixpoint.Types.Refinements.D1Expr
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_4Bop
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_3Bop
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_2Bop
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_1Bop
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_0Bop
instance GHC.Generics.Datatype Language.Fixpoint.Types.Refinements.D1Bop
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_7Brel
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_6Brel
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_5Brel
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_4Brel
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_3Brel
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_2Brel
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_1Brel
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_0Brel
instance GHC.Generics.Datatype Language.Fixpoint.Types.Refinements.D1Brel
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_2Constant
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_1Constant
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_0Constant
instance GHC.Generics.Datatype Language.Fixpoint.Types.Refinements.D1Constant
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_0SymConst
instance GHC.Generics.Datatype Language.Fixpoint.Types.Refinements.D1SymConst
instance GHC.Generics.Selector Language.Fixpoint.Types.Refinements.S1_0_0KVar
instance GHC.Generics.Constructor Language.Fixpoint.Types.Refinements.C1_0KVar
instance GHC.Generics.Datatype Language.Fixpoint.Types.Refinements.D1KVar
instance GHC.Generics.Generic Language.Fixpoint.Types.Refinements.SortedReft
instance Data.Data.Data Language.Fixpoint.Types.Refinements.SortedReft
instance GHC.Classes.Eq Language.Fixpoint.Types.Refinements.SortedReft
instance GHC.Generics.Generic Language.Fixpoint.Types.Refinements.Reft
instance Data.Data.Data Language.Fixpoint.Types.Refinements.Reft
instance GHC.Classes.Eq Language.Fixpoint.Types.Refinements.Reft
instance GHC.Generics.Generic Language.Fixpoint.Types.Refinements.Subst
instance Data.Data.Data Language.Fixpoint.Types.Refinements.Subst
instance GHC.Classes.Eq Language.Fixpoint.Types.Refinements.Subst
instance GHC.Generics.Generic Language.Fixpoint.Types.Refinements.Expr
instance Data.Data.Data Language.Fixpoint.Types.Refinements.Expr
instance GHC.Show.Show Language.Fixpoint.Types.Refinements.Expr
instance GHC.Classes.Eq Language.Fixpoint.Types.Refinements.Expr
instance GHC.Generics.Generic Language.Fixpoint.Types.Refinements.Bop
instance Data.Data.Data Language.Fixpoint.Types.Refinements.Bop
instance GHC.Show.Show Language.Fixpoint.Types.Refinements.Bop
instance GHC.Classes.Ord Language.Fixpoint.Types.Refinements.Bop
instance GHC.Classes.Eq Language.Fixpoint.Types.Refinements.Bop
instance GHC.Generics.Generic Language.Fixpoint.Types.Refinements.Brel
instance Data.Data.Data Language.Fixpoint.Types.Refinements.Brel
instance GHC.Show.Show Language.Fixpoint.Types.Refinements.Brel
instance GHC.Classes.Ord Language.Fixpoint.Types.Refinements.Brel
instance GHC.Classes.Eq Language.Fixpoint.Types.Refinements.Brel
instance GHC.Generics.Generic Language.Fixpoint.Types.Refinements.Constant
instance Data.Data.Data Language.Fixpoint.Types.Refinements.Constant
instance GHC.Show.Show Language.Fixpoint.Types.Refinements.Constant
instance GHC.Classes.Ord Language.Fixpoint.Types.Refinements.Constant
instance GHC.Classes.Eq Language.Fixpoint.Types.Refinements.Constant
instance GHC.Generics.Generic Language.Fixpoint.Types.Refinements.SymConst
instance Data.Data.Data Language.Fixpoint.Types.Refinements.SymConst
instance GHC.Show.Show Language.Fixpoint.Types.Refinements.SymConst
instance GHC.Classes.Ord Language.Fixpoint.Types.Refinements.SymConst
instance GHC.Classes.Eq Language.Fixpoint.Types.Refinements.SymConst
instance Data.String.IsString Language.Fixpoint.Types.Refinements.KVar
instance GHC.Generics.Generic Language.Fixpoint.Types.Refinements.KVar
instance Data.Data.Data Language.Fixpoint.Types.Refinements.KVar
instance GHC.Classes.Ord Language.Fixpoint.Types.Refinements.KVar
instance GHC.Classes.Eq Language.Fixpoint.Types.Refinements.KVar
instance Control.DeepSeq.NFData Language.Fixpoint.Types.Refinements.KVar
instance Control.DeepSeq.NFData Language.Fixpoint.Types.Refinements.Subst
instance Control.DeepSeq.NFData Language.Fixpoint.Types.Refinements.Constant
instance Control.DeepSeq.NFData Language.Fixpoint.Types.Refinements.SymConst
instance Control.DeepSeq.NFData Language.Fixpoint.Types.Refinements.Brel
instance Control.DeepSeq.NFData Language.Fixpoint.Types.Refinements.Bop
instance Control.DeepSeq.NFData Language.Fixpoint.Types.Refinements.Expr
instance Control.DeepSeq.NFData Language.Fixpoint.Types.Refinements.Reft
instance Control.DeepSeq.NFData Language.Fixpoint.Types.Refinements.SortedReft
instance (Data.Hashable.Class.Hashable k, GHC.Classes.Eq k, Data.Binary.Class.Binary k, Data.Binary.Class.Binary v) => Data.Binary.Class.Binary (Data.HashMap.Base.HashMap k v)
instance Data.Binary.Class.Binary Language.Fixpoint.Types.Refinements.KVar
instance Data.Binary.Class.Binary Language.Fixpoint.Types.Refinements.Subst
instance Data.Binary.Class.Binary Language.Fixpoint.Types.Refinements.Constant
instance Data.Binary.Class.Binary Language.Fixpoint.Types.Refinements.SymConst
instance Data.Binary.Class.Binary Language.Fixpoint.Types.Refinements.Brel
instance Data.Binary.Class.Binary Language.Fixpoint.Types.Refinements.Bop
instance Data.Binary.Class.Binary Language.Fixpoint.Types.Refinements.Expr
instance Data.Binary.Class.Binary Language.Fixpoint.Types.Refinements.Reft
instance Data.Binary.Class.Binary Language.Fixpoint.Types.Refinements.SortedReft
instance GHC.Show.Show Language.Fixpoint.Types.Refinements.KVar
instance Data.Hashable.Class.Hashable Language.Fixpoint.Types.Refinements.KVar
instance Data.Hashable.Class.Hashable Language.Fixpoint.Types.Refinements.Brel
instance Data.Hashable.Class.Hashable Language.Fixpoint.Types.Refinements.Bop
instance Data.Hashable.Class.Hashable Language.Fixpoint.Types.Refinements.SymConst
instance Data.Hashable.Class.Hashable Language.Fixpoint.Types.Refinements.Constant
instance GHC.Show.Show Language.Fixpoint.Types.Refinements.Subst
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Language.Fixpoint.Types.Refinements.Subst
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Language.Fixpoint.Types.Refinements.Constant
instance Language.Fixpoint.Types.Names.Symbolic Language.Fixpoint.Types.Refinements.SymConst
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Language.Fixpoint.Types.Refinements.SymConst
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Language.Fixpoint.Types.Refinements.KVar
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Language.Fixpoint.Types.Refinements.Brel
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Language.Fixpoint.Types.Refinements.Bop
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Language.Fixpoint.Types.Refinements.Expr
instance Language.Fixpoint.Types.PrettyPrint.PPrint Language.Fixpoint.Types.Refinements.Constant
instance Language.Fixpoint.Types.PrettyPrint.PPrint Language.Fixpoint.Types.Refinements.Brel
instance Language.Fixpoint.Types.PrettyPrint.PPrint Language.Fixpoint.Types.Refinements.Bop
instance Language.Fixpoint.Types.PrettyPrint.PPrint Language.Fixpoint.Types.Sorts.Sort
instance Language.Fixpoint.Types.PrettyPrint.PPrint Language.Fixpoint.Types.Refinements.KVar
instance Language.Fixpoint.Types.PrettyPrint.PPrint Language.Fixpoint.Types.Refinements.SymConst
instance Language.Fixpoint.Types.PrettyPrint.PPrint Language.Fixpoint.Types.Refinements.Expr
instance Language.Fixpoint.Types.Refinements.Expression Language.Fixpoint.Types.Refinements.Expr
instance Language.Fixpoint.Types.Refinements.Expression Language.Fixpoint.Types.Names.Symbol
instance Language.Fixpoint.Types.Refinements.Expression Data.Text.Internal.Text
instance Language.Fixpoint.Types.Refinements.Expression GHC.Integer.Type.Integer
instance Language.Fixpoint.Types.Refinements.Expression GHC.Types.Int
instance Language.Fixpoint.Types.Refinements.Predicate Language.Fixpoint.Types.Names.Symbol
instance Language.Fixpoint.Types.Refinements.Predicate Language.Fixpoint.Types.Refinements.Expr
instance Language.Fixpoint.Types.Refinements.Predicate GHC.Types.Bool
instance Language.Fixpoint.Types.Refinements.Expression a => Language.Fixpoint.Types.Refinements.Expression (Language.Fixpoint.Types.Spans.Located a)
instance Language.Fixpoint.Types.Refinements.Falseable Language.Fixpoint.Types.Refinements.Expr
instance Language.Fixpoint.Types.Refinements.Falseable Language.Fixpoint.Types.Refinements.Reft
instance Language.Fixpoint.Types.Refinements.Subable a => Language.Fixpoint.Types.Refinements.Subable (Language.Fixpoint.Types.Spans.Located a)


-- | This module contains the various instances for Subable, which (should)
--   depend on the visitors, and hence cannot be in the same place as the
--   <tt>Term</tt> definitions.
module Language.Fixpoint.Types.Substitutions
mkSubst :: [(Symbol, Expr)] -> Subst
isEmptySubst :: Subst -> Bool
substExcept :: Subst -> [Symbol] -> Subst
substfExcept :: (Symbol -> Expr) -> [Symbol] -> Symbol -> Expr
subst1Except :: (Subable a) => [Symbol] -> a -> (Symbol, Expr) -> a
targetSubstSyms :: Subst -> [Symbol]
instance GHC.Base.Monoid Language.Fixpoint.Types.Refinements.Subst
instance Language.Fixpoint.Types.Refinements.Subable ()
instance (Language.Fixpoint.Types.Refinements.Subable a, Language.Fixpoint.Types.Refinements.Subable b) => Language.Fixpoint.Types.Refinements.Subable (a, b)
instance Language.Fixpoint.Types.Refinements.Subable a => Language.Fixpoint.Types.Refinements.Subable [a]
instance Language.Fixpoint.Types.Refinements.Subable a => Language.Fixpoint.Types.Refinements.Subable (Data.HashMap.Base.HashMap k a)
instance Language.Fixpoint.Types.Refinements.Subable Language.Fixpoint.Types.Names.Symbol
instance Language.Fixpoint.Types.Refinements.Subable Language.Fixpoint.Types.Refinements.Expr
instance GHC.Base.Monoid Language.Fixpoint.Types.Refinements.Expr
instance GHC.Base.Monoid Language.Fixpoint.Types.Refinements.Reft
instance GHC.Base.Monoid Language.Fixpoint.Types.Refinements.SortedReft
instance Language.Fixpoint.Types.Refinements.Subable Language.Fixpoint.Types.Refinements.Reft
instance Language.Fixpoint.Types.Refinements.Subable Language.Fixpoint.Types.Refinements.SortedReft
instance Language.Fixpoint.Types.Refinements.Reftable ()
instance Language.Fixpoint.Types.Refinements.Reftable Language.Fixpoint.Types.Refinements.Reft
instance Language.Fixpoint.Types.Refinements.Reftable Language.Fixpoint.Types.Refinements.SortedReft
instance Language.Fixpoint.Types.PrettyPrint.PPrint Language.Fixpoint.Types.Refinements.Reft
instance Language.Fixpoint.Types.PrettyPrint.PPrint Language.Fixpoint.Types.Refinements.SortedReft
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Language.Fixpoint.Types.Refinements.Reft
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Language.Fixpoint.Types.Refinements.SortedReft
instance GHC.Show.Show Language.Fixpoint.Types.Refinements.Reft
instance GHC.Show.Show Language.Fixpoint.Types.Refinements.SortedReft

module Language.Fixpoint.Types.Environments
data SEnv a
data SESearch a
Found :: a -> SESearch a
Alts :: [Symbol] -> SESearch a
emptySEnv :: SEnv a
toListSEnv :: SEnv a -> [(Symbol, a)]
fromListSEnv :: [(Symbol, a)] -> SEnv a
mapSEnvWithKey :: ((Symbol, a1) -> (Symbol, a)) -> SEnv a1 -> SEnv a
mapSEnv :: (a1 -> a) -> SEnv a1 -> SEnv a
insertSEnv :: Symbol -> a -> SEnv a -> SEnv a
deleteSEnv :: Symbol -> SEnv a -> SEnv a
memberSEnv :: Symbol -> SEnv a -> Bool
lookupSEnv :: Symbol -> SEnv v -> Maybe v
intersectWithSEnv :: (v1 -> v2 -> a) -> SEnv v1 -> SEnv v2 -> SEnv a
filterSEnv :: (a -> Bool) -> SEnv a -> SEnv a
lookupSEnvWithDistance :: Symbol -> SEnv a -> SESearch a
envCs :: BindEnv -> IBindEnv -> [(Symbol, SortedReft)]
data IBindEnv
type BindId = Int
type BindMap a = HashMap BindId a

-- | Functions for Indexed Bind Environment
emptyIBindEnv :: IBindEnv
insertsIBindEnv :: [BindId] -> IBindEnv -> IBindEnv
deleteIBindEnv :: BindId -> IBindEnv -> IBindEnv
elemsIBindEnv :: IBindEnv -> [BindId]
type BindEnv = SizedEnv (Symbol, SortedReft)
beBinds :: SizedEnv a -> BindMap a

-- | Functions for Global Binder Environment
insertBindEnv :: Symbol -> SortedReft -> BindEnv -> (BindId, BindEnv)
emptyBindEnv :: BindEnv
lookupBindEnv :: BindId -> BindEnv -> (Symbol, SortedReft)
mapBindEnv :: ((Symbol, SortedReft) -> (Symbol, SortedReft)) -> BindEnv -> BindEnv
adjustBindEnv :: ((Symbol, SortedReft) -> (Symbol, SortedReft)) -> BindId -> BindEnv -> BindEnv
bindEnvFromList :: [(BindId, Symbol, SortedReft)] -> BindEnv
bindEnvToList :: BindEnv -> [(BindId, Symbol, SortedReft)]
unionIBindEnv :: IBindEnv -> IBindEnv -> IBindEnv
instance GHC.Generics.Selector Language.Fixpoint.Types.Environments.S1_0_1SizedEnv
instance GHC.Generics.Selector Language.Fixpoint.Types.Environments.S1_0_0SizedEnv
instance GHC.Generics.Constructor Language.Fixpoint.Types.Environments.C1_0SizedEnv
instance GHC.Generics.Datatype Language.Fixpoint.Types.Environments.D1SizedEnv
instance GHC.Generics.Selector Language.Fixpoint.Types.Environments.S1_0_0SEnv
instance GHC.Generics.Constructor Language.Fixpoint.Types.Environments.C1_0SEnv
instance GHC.Generics.Datatype Language.Fixpoint.Types.Environments.D1SEnv
instance GHC.Generics.Constructor Language.Fixpoint.Types.Environments.C1_0IBindEnv
instance GHC.Generics.Datatype Language.Fixpoint.Types.Environments.D1IBindEnv
instance Data.Traversable.Traversable Language.Fixpoint.Types.Environments.SizedEnv
instance GHC.Generics.Generic (Language.Fixpoint.Types.Environments.SizedEnv a)
instance Data.Foldable.Foldable Language.Fixpoint.Types.Environments.SizedEnv
instance GHC.Base.Functor Language.Fixpoint.Types.Environments.SizedEnv
instance GHC.Show.Show a => GHC.Show.Show (Language.Fixpoint.Types.Environments.SizedEnv a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Fixpoint.Types.Environments.SizedEnv a)
instance Data.Traversable.Traversable Language.Fixpoint.Types.Environments.SEnv
instance Data.Foldable.Foldable Language.Fixpoint.Types.Environments.SEnv
instance GHC.Generics.Generic (Language.Fixpoint.Types.Environments.SEnv a)
instance Data.Data.Data a => Data.Data.Data (Language.Fixpoint.Types.Environments.SEnv a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Fixpoint.Types.Environments.SEnv a)
instance GHC.Generics.Generic Language.Fixpoint.Types.Environments.IBindEnv
instance Data.Data.Data Language.Fixpoint.Types.Environments.IBindEnv
instance GHC.Classes.Eq Language.Fixpoint.Types.Environments.IBindEnv
instance GHC.Base.Functor Language.Fixpoint.Types.Environments.SEnv
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Language.Fixpoint.Types.Environments.BindEnv
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint a => Language.Fixpoint.Types.PrettyPrint.Fixpoint (Language.Fixpoint.Types.Environments.SEnv a)
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint (Language.Fixpoint.Types.Environments.SEnv a) => GHC.Show.Show (Language.Fixpoint.Types.Environments.SEnv a)
instance GHC.Base.Monoid (Language.Fixpoint.Types.Environments.SEnv a)
instance GHC.Base.Monoid Language.Fixpoint.Types.Environments.BindEnv
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Language.Fixpoint.Types.Environments.IBindEnv
instance Control.DeepSeq.NFData Language.Fixpoint.Types.Environments.IBindEnv
instance Control.DeepSeq.NFData Language.Fixpoint.Types.Environments.BindEnv
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Language.Fixpoint.Types.Environments.SEnv a)
instance Data.Binary.Class.Binary Language.Fixpoint.Types.Environments.IBindEnv
instance Data.Binary.Class.Binary Language.Fixpoint.Types.Environments.BindEnv
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Language.Fixpoint.Types.Environments.SEnv a)
instance (Data.Hashable.Class.Hashable a, GHC.Classes.Eq a, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Data.HashSet.HashSet a)


-- | This module contains the top-level query data types and elements,
--   including (Horn) implication &amp; well-formedness constraints and
--   sets.
module Language.Fixpoint.Types.Constraints

-- | Top-level Queries
type FInfo a = GInfo SubC a
type SInfo a = GInfo SimpC a
data GInfo c a
FI :: HashMap Integer (c a) -> HashMap KVar (WfC a) -> !BindEnv -> !(SEnv Sort) -> Kuts -> ![Qualifier] -> HashMap BindId a -> FilePath -> GInfo c a
[cm] :: GInfo c a -> HashMap Integer (c a)
[ws] :: GInfo c a -> HashMap KVar (WfC a)
[bs] :: GInfo c a -> !BindEnv
[lits] :: GInfo c a -> !(SEnv Sort)
[kuts] :: GInfo c a -> Kuts
[quals] :: GInfo c a -> ![Qualifier]
[bindInfo] :: GInfo c a -> HashMap BindId a
[fileName] :: GInfo c a -> FilePath

-- | Query Conversions: FInfo to SInfo
convertFormat :: (Fixpoint a) => FInfo a -> SInfo a

-- | Rendering Queries
toFixpoint :: (Fixpoint a, Fixpoint (c a)) => Config -> GInfo c a -> Doc
writeFInfo :: (Fixpoint a, Fixpoint (c a)) => Config -> GInfo c a -> FilePath -> IO ()

-- | Constructing Queries
fi :: [SubC a] -> [WfC a] -> BindEnv -> SEnv Sort -> Kuts -> [Qualifier] -> HashMap BindId a -> FilePath -> GInfo SubC a
data WfC a
WfC :: !IBindEnv -> (Symbol, Sort, KVar) -> !a -> WfC a
[wenv] :: WfC a -> !IBindEnv
[wrft] :: WfC a -> (Symbol, Sort, KVar)
[winfo] :: WfC a -> !a
data SubC a
mkSubC :: IBindEnv -> SortedReft -> SortedReft -> Maybe Integer -> Tag -> a -> SubC a
subcId :: (TaggedC c a) => c a -> Integer
slhs :: SubC a -> SortedReft
srhs :: SubC a -> SortedReft
subC :: IBindEnv -> SortedReft -> SortedReft -> Maybe Integer -> Tag -> a -> [SubC a]

-- | "Smart Constructors" for Constraints ---------------------------------
wfC :: IBindEnv -> SortedReft -> a -> [WfC a]
data SimpC a
SimpC :: !IBindEnv -> !Expr -> !(Maybe Integer) -> !Tag -> !a -> SimpC a
[_cenv] :: SimpC a -> !IBindEnv
[_crhs] :: SimpC a -> !Expr
[_cid] :: SimpC a -> !(Maybe Integer)
[_ctag] :: SimpC a -> !Tag
[_cinfo] :: SimpC a -> !a

-- | Constraints
--   ---------------------------------------------------------------
type Tag = [Int]
class TaggedC c a
senv :: TaggedC c a => c a -> IBindEnv
sid :: TaggedC c a => c a -> Maybe Integer
stag :: TaggedC c a => c a -> Tag
sinfo :: TaggedC c a => c a -> a
clhs :: TaggedC c a => BindEnv -> c a -> [(Symbol, SortedReft)]
crhs :: TaggedC c a => c a -> Expr
addIds :: [SubC a] -> [(Integer, SubC a)]
shiftVV :: Reft -> Symbol -> Reft

-- | Solutions and Results
type FixSolution = HashMap KVar Expr
data Result a
Result :: FixResult a -> FixSolution -> Result a
[resStatus] :: Result a -> FixResult a
[resSolution] :: Result a -> FixSolution

-- | Qualifiers
--   ----------------------------------------------------------------
data Qualifier
Q :: Symbol -> [(Symbol, Sort)] -> Expr -> !SourcePos -> Qualifier

-- | Name
[q_name] :: Qualifier -> Symbol

-- | Parameters
[q_params] :: Qualifier -> [(Symbol, Sort)]

-- | Predicate
[q_body] :: Qualifier -> Expr

-- | Source Location
[q_pos] :: Qualifier -> !SourcePos

-- | Constraint Cut Sets
--   -------------------------------------------------------
newtype Kuts
KS :: HashSet KVar -> Kuts
[ksVars] :: Kuts -> HashSet KVar
ksMember :: KVar -> Kuts -> Bool
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_7GInfo
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_6GInfo
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_5GInfo
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_4GInfo
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_3GInfo
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_2GInfo
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_1GInfo
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_0GInfo
instance GHC.Generics.Constructor Language.Fixpoint.Types.Constraints.C1_0GInfo
instance GHC.Generics.Datatype Language.Fixpoint.Types.Constraints.D1GInfo
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_0Kuts
instance GHC.Generics.Constructor Language.Fixpoint.Types.Constraints.C1_0Kuts
instance GHC.Generics.Datatype Language.Fixpoint.Types.Constraints.D1Kuts
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_3Qualifier
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_2Qualifier
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_1Qualifier
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_0Qualifier
instance GHC.Generics.Constructor Language.Fixpoint.Types.Constraints.C1_0Qualifier
instance GHC.Generics.Datatype Language.Fixpoint.Types.Constraints.D1Qualifier
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_1Result
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_0Result
instance GHC.Generics.Constructor Language.Fixpoint.Types.Constraints.C1_0Result
instance GHC.Generics.Datatype Language.Fixpoint.Types.Constraints.D1Result
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_4SimpC
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_3SimpC
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_2SimpC
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_1SimpC
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_0SimpC
instance GHC.Generics.Constructor Language.Fixpoint.Types.Constraints.C1_0SimpC
instance GHC.Generics.Datatype Language.Fixpoint.Types.Constraints.D1SimpC
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_5SubC
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_4SubC
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_3SubC
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_2SubC
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_1SubC
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_0SubC
instance GHC.Generics.Constructor Language.Fixpoint.Types.Constraints.C1_0SubC
instance GHC.Generics.Datatype Language.Fixpoint.Types.Constraints.D1SubC
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_2WfC
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_1WfC
instance GHC.Generics.Selector Language.Fixpoint.Types.Constraints.S1_0_0WfC
instance GHC.Generics.Constructor Language.Fixpoint.Types.Constraints.C1_0WfC
instance GHC.Generics.Datatype Language.Fixpoint.Types.Constraints.D1WfC
instance GHC.Generics.Generic (Language.Fixpoint.Types.Constraints.GInfo c a)
instance GHC.Base.Functor c => GHC.Base.Functor (Language.Fixpoint.Types.Constraints.GInfo c)
instance (GHC.Show.Show a, GHC.Show.Show (c a), Language.Fixpoint.Types.PrettyPrint.Fixpoint a) => GHC.Show.Show (Language.Fixpoint.Types.Constraints.GInfo c a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq (c a)) => GHC.Classes.Eq (Language.Fixpoint.Types.Constraints.GInfo c a)
instance GHC.Generics.Generic Language.Fixpoint.Types.Constraints.Kuts
instance GHC.Show.Show Language.Fixpoint.Types.Constraints.Kuts
instance GHC.Classes.Eq Language.Fixpoint.Types.Constraints.Kuts
instance GHC.Generics.Generic Language.Fixpoint.Types.Constraints.Qualifier
instance Data.Data.Data Language.Fixpoint.Types.Constraints.Qualifier
instance GHC.Show.Show Language.Fixpoint.Types.Constraints.Qualifier
instance GHC.Classes.Eq Language.Fixpoint.Types.Constraints.Qualifier
instance GHC.Show.Show a => GHC.Show.Show (Language.Fixpoint.Types.Constraints.Result a)
instance GHC.Generics.Generic (Language.Fixpoint.Types.Constraints.Result a)
instance GHC.Base.Functor Language.Fixpoint.Types.Constraints.SimpC
instance GHC.Generics.Generic (Language.Fixpoint.Types.Constraints.SimpC a)
instance GHC.Base.Functor Language.Fixpoint.Types.Constraints.SubC
instance GHC.Generics.Generic (Language.Fixpoint.Types.Constraints.SubC a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Fixpoint.Types.Constraints.SubC a)
instance GHC.Base.Functor Language.Fixpoint.Types.Constraints.WfC
instance GHC.Generics.Generic (Language.Fixpoint.Types.Constraints.WfC a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Fixpoint.Types.Constraints.WfC a)
instance Language.Fixpoint.Types.Constraints.TaggedC Language.Fixpoint.Types.Constraints.SimpC a
instance Language.Fixpoint.Types.Constraints.TaggedC Language.Fixpoint.Types.Constraints.SubC a
instance GHC.Base.Monoid (Language.Fixpoint.Types.Constraints.Result a)
instance (GHC.Classes.Ord a, Language.Fixpoint.Types.PrettyPrint.Fixpoint a) => Language.Fixpoint.Types.PrettyPrint.Fixpoint (Language.Fixpoint.Types.Errors.FixResult (Language.Fixpoint.Types.Constraints.SubC a))
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint a => GHC.Show.Show (Language.Fixpoint.Types.Constraints.WfC a)
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint a => GHC.Show.Show (Language.Fixpoint.Types.Constraints.SubC a)
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint a => GHC.Show.Show (Language.Fixpoint.Types.Constraints.SimpC a)
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint a => Language.Fixpoint.Types.PrettyPrint.Fixpoint (Language.Fixpoint.Types.Constraints.SubC a)
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint a => Language.Fixpoint.Types.PrettyPrint.Fixpoint (Language.Fixpoint.Types.Constraints.SimpC a)
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint a => Language.Fixpoint.Types.PrettyPrint.Fixpoint (Language.Fixpoint.Types.Constraints.WfC a)
instance Data.Binary.Class.Binary Language.Fixpoint.Types.Constraints.Qualifier
instance Data.Binary.Class.Binary Language.Fixpoint.Types.Constraints.Kuts
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Language.Fixpoint.Types.Constraints.SubC a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Language.Fixpoint.Types.Constraints.WfC a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Language.Fixpoint.Types.Constraints.SimpC a)
instance (Data.Binary.Class.Binary (c a), Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Language.Fixpoint.Types.Constraints.GInfo c a)
instance Control.DeepSeq.NFData Language.Fixpoint.Types.Constraints.Qualifier
instance Control.DeepSeq.NFData Language.Fixpoint.Types.Constraints.Kuts
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Language.Fixpoint.Types.Constraints.SubC a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Language.Fixpoint.Types.Constraints.WfC a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Language.Fixpoint.Types.Constraints.SimpC a)
instance (Control.DeepSeq.NFData (c a), Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Language.Fixpoint.Types.Constraints.GInfo c a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Language.Fixpoint.Types.Constraints.Result a)
instance Language.Fixpoint.Types.Spans.Loc Language.Fixpoint.Types.Constraints.Qualifier
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Language.Fixpoint.Types.Constraints.Qualifier
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint Language.Fixpoint.Types.Constraints.Kuts
instance GHC.Base.Monoid Language.Fixpoint.Types.Constraints.Kuts
instance GHC.Base.Monoid (Language.Fixpoint.Types.Constraints.GInfo c a)
instance Language.Fixpoint.Types.PrettyPrint.PTable (Language.Fixpoint.Types.Constraints.SInfo a)


-- | This module re-exports the data types, operations and serialization
--   functions for representing Fixpoint's implication (i.e. subtyping) and
--   well-formedness constraints.
module Language.Fixpoint.Types

module Language.Fixpoint.Types.Visitor
data Visitor acc ctx
Visitor :: (ctx -> Expr -> ctx) -> (ctx -> Expr -> Expr) -> (ctx -> Expr -> acc) -> Visitor acc ctx

-- | Context <tt>ctx</tt> is built in a "top-down" fashion; not "across"
--   siblings
[ctxExpr] :: Visitor acc ctx -> ctx -> Expr -> ctx

-- | Transforms can access current <tt>ctx</tt>
[txExpr] :: Visitor acc ctx -> ctx -> Expr -> Expr

-- | Accumulations can access current <tt>ctx</tt>; <tt>acc</tt> value is
--   monoidal
[accExpr] :: Visitor acc ctx -> ctx -> Expr -> acc

-- | String Constants -----------------------------------------
class SymConsts a
symConsts :: SymConsts a => a -> [SymConst]
defaultVisitor :: Monoid acc => Visitor acc ctx
trans :: (Visitable t, Monoid a) => Visitor a ctx -> ctx -> a -> t -> t
fold :: (Visitable t, Monoid a) => Visitor a ctx -> ctx -> a -> t -> a
kvars :: Visitable t => t -> [KVar]
envKVars :: (TaggedC c a) => BindEnv -> c a -> [KVar]
rhsKVars :: (TaggedC c a) => c a -> [KVar]
mapKVars :: Visitable t => (KVar -> Maybe Expr) -> t -> t
mapKVars' :: Visitable t => ((KVar, Subst) -> Maybe Expr) -> t -> t
mapKVarSubsts :: Visitable t => (KVar -> Subst -> Subst) -> t -> t
isConcC :: (TaggedC c a) => c a -> Bool
isKvarC :: (TaggedC c a) => c a -> Bool

-- | Visitors over <tt>Sort</tt>
foldSort :: (a -> Sort -> a) -> a -> Sort -> a
mapSort :: (Sort -> Sort) -> Sort -> Sort
instance Language.Fixpoint.Types.Visitor.Visitable Language.Fixpoint.Types.Refinements.Expr
instance Language.Fixpoint.Types.Visitor.Visitable Language.Fixpoint.Types.Refinements.Reft
instance Language.Fixpoint.Types.Visitor.Visitable Language.Fixpoint.Types.Refinements.SortedReft
instance Language.Fixpoint.Types.Visitor.Visitable (Language.Fixpoint.Types.Names.Symbol, Language.Fixpoint.Types.Refinements.SortedReft)
instance Language.Fixpoint.Types.Visitor.Visitable Language.Fixpoint.Types.Environments.BindEnv
instance Language.Fixpoint.Types.Visitor.Visitable (Language.Fixpoint.Types.Constraints.SimpC a)
instance Language.Fixpoint.Types.Visitor.Visitable (Language.Fixpoint.Types.Constraints.SInfo a)
instance Language.Fixpoint.Types.Visitor.SymConsts (Language.Fixpoint.Types.Constraints.FInfo a)
instance Language.Fixpoint.Types.Visitor.SymConsts Language.Fixpoint.Types.Environments.BindEnv
instance Language.Fixpoint.Types.Visitor.SymConsts (Language.Fixpoint.Types.Constraints.SubC a)
instance Language.Fixpoint.Types.Visitor.SymConsts Language.Fixpoint.Types.Refinements.SortedReft
instance Language.Fixpoint.Types.Visitor.SymConsts Language.Fixpoint.Types.Refinements.Reft
instance Language.Fixpoint.Types.Visitor.SymConsts Language.Fixpoint.Types.Refinements.Expr


-- | This module contains the types defining an SMTLIB2 interface.
module Language.Fixpoint.Smt.Types

-- | Types ---------------------------------------------------------------
type Raw = Text

-- | Commands issued to SMT engine
data Command
Push :: Command
Pop :: Command
CheckSat :: Command
Declare :: Symbol -> [Sort] -> Sort -> Command
Define :: Sort -> Command
Assert :: (Maybe Int) -> Expr -> Command
Distinct :: [Expr] -> Command
GetValue :: [Symbol] -> Command

-- | Responses received from SMT engine
data Response
Ok :: Response
Sat :: Response
Unsat :: Response
Unknown :: Response
Values :: [(Symbol, Raw)] -> Response
Error :: Raw -> Response

-- | Types that can be serialized
class SMTLIB2 a
smt2 :: SMTLIB2 a => a -> Text

-- | Information about the external SMT process
data Context
Ctx :: ProcessHandle -> Handle -> Handle -> Maybe Handle -> Bool -> Context
[pId] :: Context -> ProcessHandle
[cIn] :: Context -> Handle
[cOut] :: Context -> Handle
[cLog] :: Context -> Maybe Handle
[verbose] :: Context -> Bool

-- | Theory Symbol
data TheorySymbol
Thy :: Symbol -> Raw -> Sort -> TheorySymbol
[tsSym] :: TheorySymbol -> Symbol
[tsRaw] :: TheorySymbol -> Raw
[tsSort] :: TheorySymbol -> Sort

-- | AST Conversion: Types that can be serialized ---------------------
format :: Params ps => Format -> ps -> Text
instance GHC.Show.Show Language.Fixpoint.Smt.Types.TheorySymbol
instance GHC.Classes.Ord Language.Fixpoint.Smt.Types.TheorySymbol
instance GHC.Classes.Eq Language.Fixpoint.Smt.Types.TheorySymbol
instance GHC.Show.Show Language.Fixpoint.Smt.Types.Response
instance GHC.Classes.Eq Language.Fixpoint.Smt.Types.Response
instance GHC.Show.Show Language.Fixpoint.Smt.Types.Command
instance GHC.Classes.Eq Language.Fixpoint.Smt.Types.Command

module Language.Fixpoint.Smt.Bitvector
data Bv
Bv :: BvSize -> String -> Bv
data BvSize
S32 :: BvSize
S64 :: BvSize
data BvOp
BvAnd :: BvOp
BvOr :: BvOp

-- | Construct the bitvector <a>Sort</a> from its <a>BvSize</a>
mkSort :: BvSize -> Sort

-- | Apply some bitvector operator to a list of arguments
eOp :: BvOp -> [Expr] -> Expr
bvTyCon :: FTycon
instance GHC.Generics.Constructor Language.Fixpoint.Smt.Bitvector.C1_1BvOp
instance GHC.Generics.Constructor Language.Fixpoint.Smt.Bitvector.C1_0BvOp
instance GHC.Generics.Datatype Language.Fixpoint.Smt.Bitvector.D1BvOp
instance GHC.Generics.Constructor Language.Fixpoint.Smt.Bitvector.C1_1BvSize
instance GHC.Generics.Constructor Language.Fixpoint.Smt.Bitvector.C1_0BvSize
instance GHC.Generics.Datatype Language.Fixpoint.Smt.Bitvector.D1BvSize
instance GHC.Generics.Generic Language.Fixpoint.Smt.Bitvector.BvOp
instance Data.Data.Data Language.Fixpoint.Smt.Bitvector.BvOp
instance GHC.Show.Show Language.Fixpoint.Smt.Bitvector.BvOp
instance GHC.Classes.Ord Language.Fixpoint.Smt.Bitvector.BvOp
instance GHC.Classes.Eq Language.Fixpoint.Smt.Bitvector.BvOp
instance GHC.Generics.Generic Language.Fixpoint.Smt.Bitvector.BvSize
instance Data.Data.Data Language.Fixpoint.Smt.Bitvector.BvSize
instance GHC.Show.Show Language.Fixpoint.Smt.Bitvector.BvSize
instance GHC.Classes.Ord Language.Fixpoint.Smt.Bitvector.BvSize
instance GHC.Classes.Eq Language.Fixpoint.Smt.Bitvector.BvSize
instance Language.Fixpoint.Types.Refinements.Expression Language.Fixpoint.Smt.Bitvector.Bv

module Language.Fixpoint.Smt.Theories
smt2App :: LocSymbol -> [Text] -> Maybe Text
smt2Sort :: Sort -> Maybe Text

-- | Exported API
--   -------------------------------------------------------------
smt2Symbol :: Symbol -> Maybe Text
preamble :: Bool -> SMTSolver -> [Text]


-- | This module contains the code for serializing Haskell values into
--   SMTLIB2 format, that is, the instances for the <tt>SMTLIB2</tt>
--   typeclass. We split it into a separate module as it depends on
--   Theories (see <tt>smt2App</tt>).
module Language.Fixpoint.Smt.Serialize
smt2Bop :: Bop -> Expr -> Expr -> Text
uOp :: Bop -> Located Symbol
smt2App :: LocSymbol -> [Expr] -> Text
smt2App' :: SMTLIB2 a => a -> [Text] -> Text
mkRel :: (SMTLIB2 a, SMTLIB2 a1) => Brel -> a -> a1 -> Text
mkNe :: (SMTLIB2 a, SMTLIB2 a1) => a -> a1 -> Text
smt2s :: SMTLIB2 a => [a] -> Text
smt2many :: [Text] -> Text
instance Language.Fixpoint.Smt.Types.SMTLIB2 Language.Fixpoint.Types.Sorts.Sort
instance Language.Fixpoint.Smt.Types.SMTLIB2 Language.Fixpoint.Types.Names.Symbol
instance Language.Fixpoint.Smt.Types.SMTLIB2 (Language.Fixpoint.Types.Names.Symbol, Language.Fixpoint.Types.Sorts.Sort)
instance Language.Fixpoint.Smt.Types.SMTLIB2 Language.Fixpoint.Types.Refinements.SymConst
instance Language.Fixpoint.Smt.Types.SMTLIB2 Language.Fixpoint.Types.Refinements.Constant
instance Language.Fixpoint.Smt.Types.SMTLIB2 Language.Fixpoint.Types.Names.LocSymbol
instance Language.Fixpoint.Smt.Types.SMTLIB2 Language.Fixpoint.Types.Refinements.Bop
instance Language.Fixpoint.Smt.Types.SMTLIB2 Language.Fixpoint.Types.Refinements.Brel
instance Language.Fixpoint.Smt.Types.SMTLIB2 Language.Fixpoint.Types.Refinements.Expr
instance Language.Fixpoint.Smt.Types.SMTLIB2 Language.Fixpoint.Smt.Types.Command


-- | This module contains an SMTLIB2 interface for 1. checking the
--   validity, and, 2. computing satisfying assignments for formulas. By
--   implementing a binary interface over the SMTLIB2 format defined at
--   <a>http://www.smt-lib.org/</a>
--   <a>http://www.grammatech.com/resource/smt/SMTLIBTutorial.pdf</a>
module Language.Fixpoint.Smt.Interface

-- | Commands issued to SMT engine
data Command
Push :: Command
Pop :: Command
CheckSat :: Command
Declare :: Symbol -> [Sort] -> Sort -> Command
Define :: Sort -> Command
Assert :: (Maybe Int) -> Expr -> Command
Distinct :: [Expr] -> Command
GetValue :: [Symbol] -> Command

-- | Responses received from SMT engine
data Response
Ok :: Response
Sat :: Response
Unsat :: Response
Unknown :: Response
Values :: [(Symbol, Raw)] -> Response
Error :: Raw -> Response

-- | Types that can be serialized
class SMTLIB2 a
smt2 :: SMTLIB2 a => a -> Text

-- | Information about the external SMT process
data Context
Ctx :: ProcessHandle -> Handle -> Handle -> Maybe Handle -> Bool -> Context
[pId] :: Context -> ProcessHandle
[cIn] :: Context -> Handle
[cOut] :: Context -> Handle
[cLog] :: Context -> Maybe Handle
[verbose] :: Context -> Bool

-- | SMT Context ---------------------------------------------------------
makeContext :: Bool -> SMTSolver -> FilePath -> IO Context
makeContextNoLog :: Bool -> SMTSolver -> IO Context
cleanupContext :: Context -> IO ExitCode

-- | SMT IO --------------------------------------------------------------
command :: Context -> Command -> IO Response
smtWrite :: Context -> Text -> IO ()
smtDecl :: Context -> Symbol -> Sort -> IO ()
smtAssert :: Context -> Expr -> IO ()
smtCheckUnsat :: Context -> IO Bool
smtBracket :: Context -> IO a -> IO a
smtDistinct :: Context -> [Expr] -> IO ()

-- | type ClosedPred E = {v:Pred | subset (vars v) (keys E) } checkValid ::
--   e:Env -&gt; ClosedPred e -&gt; ClosedPred e -&gt; IO Bool
checkValid :: Bool -> FilePath -> [(Symbol, Sort)] -> Expr -> Expr -> IO Bool
checkValidWithContext :: Context -> [(Symbol, Sort)] -> Expr -> Expr -> IO Bool

-- | If you already HAVE a context, where all the variables have declared
--   types (e.g. if you want to make MANY repeated Queries)
checkValids :: Bool -> FilePath -> [(Symbol, Sort)] -> [Expr] -> IO [Bool]
makeZ3Context :: FilePath -> [(Symbol, Sort)] -> IO Context


-- | This module implements functions that print out statistics about the
--   constraints.
module Language.Fixpoint.Partition

-- | Constraint Partition Container -------------------------------------
data CPart a
CPart :: HashMap KVar (WfC a) -> HashMap Integer (SubC a) -> FilePath -> CPart a
[pws] :: CPart a -> HashMap KVar (WfC a)
[pcm] :: CPart a -> HashMap Integer (SubC a)
[cFileName] :: CPart a -> FilePath
partition :: (Fixpoint a) => Config -> FInfo a -> IO (Result a)

-- | Partition an FInfo into multiple disjoint FInfos
partition' :: Maybe MCInfo -> FInfo a -> (KVGraph, [FInfo a])

-- | Partition an FInfo into a specific number of partitions of roughly
--   equal amounts of work
partitionN :: MCInfo -> FInfo a -> [CPart a] -> [FInfo a]

-- | Multicore info -----------------------------------------------------
data MCInfo
MCInfo :: Int -> Int -> Int -> MCInfo
[mcCores] :: MCInfo -> Int
[mcMinPartSize] :: MCInfo -> Int
[mcMaxPartSize] :: MCInfo -> Int
mcInfo :: Config -> IO MCInfo
instance GHC.Generics.Constructor Language.Fixpoint.Partition.C1_1CVertex
instance GHC.Generics.Constructor Language.Fixpoint.Partition.C1_0CVertex
instance GHC.Generics.Datatype Language.Fixpoint.Partition.D1CVertex
instance GHC.Generics.Generic Language.Fixpoint.Partition.CVertex
instance GHC.Show.Show Language.Fixpoint.Partition.CVertex
instance GHC.Classes.Ord Language.Fixpoint.Partition.CVertex
instance GHC.Classes.Eq Language.Fixpoint.Partition.CVertex
instance GHC.Show.Show Language.Fixpoint.Partition.MCInfo
instance GHC.Base.Monoid (Language.Fixpoint.Partition.CPart a)
instance Language.Fixpoint.Types.PrettyPrint.PPrint Language.Fixpoint.Partition.CVertex
instance Data.Hashable.Class.Hashable Language.Fixpoint.Partition.CVertex

module Language.Fixpoint.Solver.Deps

-- | Compute Dependencies and Cuts ---------------------------
deps :: SInfo a -> Deps
data Deps
Deps :: !(HashSet KVar) -> !(HashSet KVar) -> Deps
[depCuts] :: Deps -> !(HashSet KVar)
[depNonCuts] :: Deps -> !(HashSet KVar)
instance GHC.Show.Show Language.Fixpoint.Solver.Deps.Deps

module Language.Fixpoint.Solver.UniqifyKVars
wfcUniqify :: SInfo a -> SInfo a


-- | This module implements functions that print out statistics about the
--   constraints.
module Language.Fixpoint.Utils.Statistics
statistics :: Config -> FInfo a -> IO (Result a)
instance GHC.Generics.Selector Language.Fixpoint.Utils.Statistics.S1_0_5Stats
instance GHC.Generics.Selector Language.Fixpoint.Utils.Statistics.S1_0_4Stats
instance GHC.Generics.Selector Language.Fixpoint.Utils.Statistics.S1_0_3Stats
instance GHC.Generics.Selector Language.Fixpoint.Utils.Statistics.S1_0_2Stats
instance GHC.Generics.Selector Language.Fixpoint.Utils.Statistics.S1_0_1Stats
instance GHC.Generics.Selector Language.Fixpoint.Utils.Statistics.S1_0_0Stats
instance GHC.Generics.Constructor Language.Fixpoint.Utils.Statistics.C1_0Stats
instance GHC.Generics.Datatype Language.Fixpoint.Utils.Statistics.D1Stats
instance GHC.Generics.Generic Language.Fixpoint.Utils.Statistics.Stats
instance GHC.Show.Show Language.Fixpoint.Utils.Statistics.Stats
instance Control.DeepSeq.NFData Language.Fixpoint.Utils.Statistics.Stats
instance Language.Fixpoint.Types.PrettyPrint.PPrint Language.Fixpoint.Utils.Statistics.Stats

module Language.Fixpoint.Parse
class Inputable a where rr' _ = rr rr = rr' ""
rr :: Inputable a => String -> a
rr' :: Inputable a => String -> String -> a
type Parser = Parsec String Integer
lexer :: GenTokenParser String u Identity
reserved :: String -> ParsecT String u Identity ()
reservedOp :: String -> ParsecT String u Identity ()
parens :: ParsecT String u Identity a -> ParsecT String u Identity a
brackets :: ParsecT String u Identity a -> ParsecT String u Identity a
angles :: ParsecT String u Identity a -> ParsecT String u Identity a
braces :: ParsecT String u Identity a -> ParsecT String u Identity a
semi :: ParsecT String u Identity String
comma :: ParsecT String u Identity String
colon :: ParsecT String u Identity String
dcolon :: Stream s m Char => ParsecT s u m String
whiteSpace :: ParsecT String u Identity ()
blanks :: Stream s m Char => ParsecT s u m [Char]
pairP :: Parser a -> Parser z -> Parser b -> Parser (a, b)
lowerIdP :: Parser Symbol
upperIdP :: Parser Symbol
symbolP :: Parser Symbol
constantP :: Parser Constant
integer :: Stream s m Char => ParsecT s u m Integer
bindP :: ParsecT String Integer Identity Symbol
sortP :: Parser Sort
mkQual :: Symbol -> [(Symbol, Sort)] -> Expr -> SourcePos -> Qualifier
exprP :: Parser Expr
predP :: Parser Expr
funAppP :: ParsecT String Integer Identity Expr

-- | Parsing Qualifiers ---------------------------------------------
qualifierP :: Parser Sort -> ParsecT String Integer Identity Qualifier
refaP :: Parser Expr
refP :: Parser (Reft -> a) -> Parser a
refDefP :: Symbol -> Parser Expr -> Parser (Reft -> a) -> Parser a
refBindP :: Parser Symbol -> Parser Expr -> Parser (Reft -> a) -> Parser a
bvSortP :: ParsecT String u Identity Sort
condIdP :: HashSet Char -> (String -> Bool) -> Parser Symbol
locParserP :: Parser a -> Parser (Located a)
locLowerIdP :: Parser (Located Symbol)
locUpperIdP :: Parser (Located Symbol)
freshIntP :: Parser Integer
doParse' :: Num u => ParsecT String u Identity a -> SourceName -> String -> a
parseFromFile :: Parser b -> SourceName -> IO b
remainderP :: Monad m => ParsecT t1 u m t -> ParsecT t1 u m (t, t1, SourcePos)
isSmall :: Char -> Bool
instance GHC.Generics.Constructor Language.Fixpoint.Parse.C1_7Def
instance GHC.Generics.Constructor Language.Fixpoint.Parse.C1_6Def
instance GHC.Generics.Constructor Language.Fixpoint.Parse.C1_5Def
instance GHC.Generics.Constructor Language.Fixpoint.Parse.C1_4Def
instance GHC.Generics.Constructor Language.Fixpoint.Parse.C1_3Def
instance GHC.Generics.Constructor Language.Fixpoint.Parse.C1_2Def
instance GHC.Generics.Constructor Language.Fixpoint.Parse.C1_1Def
instance GHC.Generics.Constructor Language.Fixpoint.Parse.C1_0Def
instance GHC.Generics.Datatype Language.Fixpoint.Parse.D1Def
instance GHC.Generics.Generic (Language.Fixpoint.Parse.Def a)
instance Language.Fixpoint.Types.PrettyPrint.Fixpoint a => GHC.Show.Show (Language.Fixpoint.Parse.Def a)
instance Language.Fixpoint.Parse.Inputable Language.Fixpoint.Types.Names.Symbol
instance Language.Fixpoint.Parse.Inputable Language.Fixpoint.Types.Refinements.Constant
instance Language.Fixpoint.Parse.Inputable Language.Fixpoint.Types.Refinements.Expr
instance Language.Fixpoint.Parse.Inputable (Language.Fixpoint.Types.Errors.FixResult GHC.Integer.Type.Integer)
instance Language.Fixpoint.Parse.Inputable (Language.Fixpoint.Types.Errors.FixResult GHC.Integer.Type.Integer, Language.Fixpoint.Types.Constraints.FixSolution)
instance Language.Fixpoint.Parse.Inputable (Language.Fixpoint.Types.Constraints.FInfo ())
instance Language.Fixpoint.Parse.Inputable Language.Fixpoint.Smt.Types.Command
instance Language.Fixpoint.Parse.Inputable [Language.Fixpoint.Smt.Types.Command]


-- | This module has the functions that perform sort-checking, and related
--   operations on Fixpoint expressions and predicates.
module Language.Fixpoint.SortCheck

-- | API for manipulating Sort Substitutions ---------------------------
data TVSubst
checkSorted :: Checkable a => SEnv Sort -> a -> Maybe Doc

-- | Checking Refinements -----------------------------------------------
checkSortedReft :: SEnv SortedReft -> [Symbol] -> SortedReft -> Maybe Doc
checkSortedReftFull :: Checkable a => SEnv SortedReft -> a -> Maybe Doc
checkSortFull :: Checkable a => SEnv SortedReft -> Sort -> a -> Maybe Doc
pruneUnsortedReft :: SEnv Sort -> SortedReft -> SortedReft

-- | Sort Unification
unify :: Sort -> Sort -> Maybe TVSubst

-- | Fast Unification; `unifyFast True` is just equality
unifyFast :: Bool -> Sort -> Sort -> Maybe TVSubst

-- | Applying a Type Substitution ---------------------------------------
apply :: TVSubst -> Sort -> Sort

-- | Exported Basic Sorts -----------------------------------------------
boolSort :: Sort

-- | Exported Basic Sorts -----------------------------------------------
strSort :: Sort

-- | Predicates on Sorts ------------------------------------------------
isFirstOrder :: Sort -> Bool
isMono :: Sort -> Bool
instance GHC.Show.Show Language.Fixpoint.SortCheck.TVSubst
instance GHC.Base.Monad Language.Fixpoint.SortCheck.CheckM
instance Control.Monad.Error.Class.MonadError GHC.Base.String Language.Fixpoint.SortCheck.CheckM
instance GHC.Base.Functor Language.Fixpoint.SortCheck.CheckM
instance GHC.Base.Applicative Language.Fixpoint.SortCheck.CheckM
instance Language.Fixpoint.SortCheck.Freshable GHC.Types.Int
instance Language.Fixpoint.SortCheck.Freshable [GHC.Types.Int]
instance Language.Fixpoint.SortCheck.Checkable Language.Fixpoint.Types.Refinements.Expr
instance Language.Fixpoint.SortCheck.Checkable Language.Fixpoint.Types.Refinements.SortedReft


-- | Validate and Transform Constraints to Ensure various Invariants
--   ------------------------- 1. Each binder must be associated with a
--   UNIQUE sort
module Language.Fixpoint.Solver.Validate
validate :: SInfo a -> ValidateM ()
sanitize :: SInfo a -> ValidateM (SInfo a)

-- | Conservative check that KVars appear at "top-level" in pred isOkRhs ::
--   F.Pred -&gt; Bool isOkRhs p = all isKvar ps || all isConc ps where ps
--   = F.conjuncts p
--   
--   symbol |-&gt; sort for EVERY variable in the FInfo
symbolSorts :: GInfo c a -> ValidateM [(Symbol, Sort)]

module Language.Fixpoint.Solver.Solution

-- | Types ----------------------------------------------------------
type Solution = Sol KBind
type Cand a = [(Expr, a)]
data EQual
EQL :: !Qualifier -> !Expr -> ![Expr] -> EQual
[eqQual] :: EQual -> !Qualifier
[eqPred] :: EQual -> !Expr
[eqArgs] :: EQual -> ![Expr]

-- | Apply Solution -------------------------------------------------
class Solvable a
apply :: Solvable a => Solution -> a -> Expr

-- | Initial Solution (from Qualifiers and WF constraints) ---------
init :: SInfo a -> Solution

-- | Update Solution ---------------------------------------------------
update :: Solution -> [KVar] -> [(KVar, EQual)] -> (Bool, Solution)

-- | Lookup Solution at KVar ----------------------------------------
lookup :: Solution -> KVar -> KBind
mkJVar :: Expr -> KBind
instance GHC.Generics.Selector Language.Fixpoint.Solver.Solution.S1_0_2EQual
instance GHC.Generics.Selector Language.Fixpoint.Solver.Solution.S1_0_1EQual
instance GHC.Generics.Selector Language.Fixpoint.Solver.Solution.S1_0_0EQual
instance GHC.Generics.Constructor Language.Fixpoint.Solver.Solution.C1_0EQual
instance GHC.Generics.Datatype Language.Fixpoint.Solver.Solution.D1EQual
instance GHC.Generics.Generic Language.Fixpoint.Solver.Solution.EQual
instance Data.Data.Data Language.Fixpoint.Solver.Solution.EQual
instance GHC.Show.Show Language.Fixpoint.Solver.Solution.EQual
instance GHC.Classes.Eq Language.Fixpoint.Solver.Solution.EQual
instance Language.Fixpoint.Types.PrettyPrint.PPrint Language.Fixpoint.Solver.Solution.EQual
instance Control.DeepSeq.NFData Language.Fixpoint.Solver.Solution.EQual
instance Language.Fixpoint.Solver.Solution.Solvable Language.Fixpoint.Solver.Solution.EQual
instance Language.Fixpoint.Solver.Solution.Solvable Language.Fixpoint.Types.Refinements.KVar
instance Language.Fixpoint.Solver.Solution.Solvable (Language.Fixpoint.Types.Refinements.KVar, Language.Fixpoint.Types.Refinements.Subst)
instance Language.Fixpoint.Solver.Solution.Solvable Language.Fixpoint.Types.Refinements.Expr
instance Language.Fixpoint.Solver.Solution.Solvable Language.Fixpoint.Types.Refinements.Reft
instance Language.Fixpoint.Solver.Solution.Solvable Language.Fixpoint.Types.Refinements.SortedReft
instance Language.Fixpoint.Solver.Solution.Solvable (Language.Fixpoint.Types.Names.Symbol, Language.Fixpoint.Types.Refinements.SortedReft)
instance Language.Fixpoint.Solver.Solution.Solvable a => Language.Fixpoint.Solver.Solution.Solvable [a]

module Language.Fixpoint.Solver.Eliminate
eliminateAll :: SInfo a -> (Solution, SInfo a)

module Language.Fixpoint.Solver.Types

-- | Dramatis Personae
type CId = Integer
type CSucc = CId -> [CId]
type CMap a = HashMap CId a
type KVRead = HashMap KVar [CId]
type DepEdge = (CId, CId, [CId])
data Slice
Slice :: [CId] -> [CId] -> [DepEdge] -> Slice

-- | CIds that transitively "reach" below
[slKVarCs] :: Slice -> [CId]

-- | CIds with Concrete RHS
[slConcCs] :: Slice -> [CId]

-- | Dependencies between slKVarCs
[slEdges] :: Slice -> [DepEdge]
data CGraph
CGraph :: [DepEdge] -> CMap Int -> CSucc -> Int -> CGraph
[gEdges] :: CGraph -> [DepEdge]
[gRanks] :: CGraph -> CMap Int
[gSucc] :: CGraph -> CSucc
[gSccs] :: CGraph -> Int

-- | CMap API -------------------------------------------------------------
lookupCMap :: (?callStack :: CallStack) => CMap a -> CId -> a
instance GHC.Show.Show Language.Fixpoint.Solver.Types.Slice
instance GHC.Classes.Eq Language.Fixpoint.Solver.Types.Slice

module Language.Fixpoint.Solver.Graph

-- | Compute constraints that transitively affect target constraints, and
--   delete everything else from F.SInfo a
slice :: (TaggedC c a) => GInfo c a -> GInfo c a
isTarget :: (TaggedC c a) => c a -> Bool

-- | Ranks from Graph -----------------------------------------------------
graphRanks :: Graph -> (Vertex -> DepEdge) -> (CMap Int, [[Vertex]])

-- | Constraint Graph -----------------------------------------------------
cGraph :: (TaggedC c a) => GInfo c a -> CGraph
gSccs :: CGraph -> Int
kvWriteBy :: (TaggedC c a) => CMap (c a) -> CId -> [KVar]
kvReadBy :: (TaggedC c a) => GInfo c a -> KVRead

module Language.Fixpoint.Solver.UniqifyBinds
renameAll :: SInfo a -> SInfo a
instance GHC.Generics.Constructor Language.Fixpoint.Solver.UniqifyBinds.C1_1Ref
instance GHC.Generics.Constructor Language.Fixpoint.Solver.UniqifyBinds.C1_0Ref
instance GHC.Generics.Datatype Language.Fixpoint.Solver.UniqifyBinds.D1Ref
instance GHC.Generics.Generic Language.Fixpoint.Solver.UniqifyBinds.Ref
instance GHC.Classes.Eq Language.Fixpoint.Solver.UniqifyBinds.Ref
instance Control.DeepSeq.NFData Language.Fixpoint.Solver.UniqifyBinds.Ref
instance Data.Hashable.Class.Hashable Language.Fixpoint.Solver.UniqifyBinds.Ref

module Language.Fixpoint.Solver.Worklist

-- | Worklist -------------------------------------------------------------
data Worklist a
data Stats

-- | Initialize worklist and slice out irrelevant constraints -------------
init :: SInfo a -> Worklist a
pop :: Worklist a -> Maybe (SimpC a, Worklist a, Bool)
push :: SimpC a -> Worklist a -> Worklist a

-- | Candidate Constraints to be checked AFTER computing Fixpoint ---------
unsatCandidates :: Worklist a -> [SimpC a]
wRanks :: Worklist a -> Int
instance GHC.Show.Show Language.Fixpoint.Solver.Worklist.WorkItem
instance GHC.Classes.Eq Language.Fixpoint.Solver.Worklist.WorkItem
instance GHC.Show.Show Language.Fixpoint.Solver.Worklist.Rank
instance GHC.Classes.Eq Language.Fixpoint.Solver.Worklist.Rank
instance GHC.Show.Show Language.Fixpoint.Solver.Worklist.Stats
instance GHC.Classes.Eq Language.Fixpoint.Solver.Worklist.Stats
instance Language.Fixpoint.Types.PrettyPrint.PPrint (Language.Fixpoint.Solver.Worklist.Worklist a)
instance Language.Fixpoint.Types.PrettyPrint.PTable Language.Fixpoint.Solver.Worklist.Stats
instance Language.Fixpoint.Types.PrettyPrint.PTable (Language.Fixpoint.Solver.Worklist.Worklist a)
instance Language.Fixpoint.Types.PrettyPrint.PPrint Language.Fixpoint.Solver.Worklist.WorkItem
instance GHC.Classes.Ord Language.Fixpoint.Solver.Worklist.WorkItem


-- | This is a wrapper around IO that permits SMT queries
module Language.Fixpoint.Solver.Monad

-- | Solver Monadic API ---------------------------------------------------
type SolveM = StateT SolverState IO
runSolverM :: Config -> GInfo c b -> Int -> SolveM a -> IO a
getBinds :: SolveM BindEnv

-- | SMT Interface --------------------------------------------------------
filterValid :: Expr -> Cand a -> SolveM [a]
data Stats
tickIter :: Bool -> SolveM Int
stats :: SolveM Stats

-- | # Refine Iterations
numIter :: Stats -> Int
instance GHC.Generics.Selector Language.Fixpoint.Solver.Monad.S1_0_4Stats
instance GHC.Generics.Selector Language.Fixpoint.Solver.Monad.S1_0_3Stats
instance GHC.Generics.Selector Language.Fixpoint.Solver.Monad.S1_0_2Stats
instance GHC.Generics.Selector Language.Fixpoint.Solver.Monad.S1_0_1Stats
instance GHC.Generics.Selector Language.Fixpoint.Solver.Monad.S1_0_0Stats
instance GHC.Generics.Constructor Language.Fixpoint.Solver.Monad.C1_0Stats
instance GHC.Generics.Datatype Language.Fixpoint.Solver.Monad.D1Stats
instance GHC.Generics.Generic Language.Fixpoint.Solver.Monad.Stats
instance GHC.Show.Show Language.Fixpoint.Solver.Monad.Stats
instance Control.DeepSeq.NFData Language.Fixpoint.Solver.Monad.Stats
instance Language.Fixpoint.Types.PrettyPrint.PTable Language.Fixpoint.Solver.Monad.Stats


-- | Solve a system of horn-clause constraints
--   ---------------------------------
module Language.Fixpoint.Solver.Solve
solve :: (NFData a, Fixpoint a) => Config -> Solution -> SInfo a -> IO (Result a)


-- | This module implements the top-level API for interfacing with Fixpoint
--   In particular it exports the functions that solve constraints supplied
--   either as .fq files or as FInfo.
module Language.Fixpoint.Solver

-- | Solve FInfo system of horn-clause constraints ------------------------
solve :: (NFData a, Fixpoint a) => Solver a

-- | Solve an .fq file ----------------------------------------------------
solveFQ :: Config -> IO ExitCode

-- | Extract ExitCode from Solver Result ----------------------------------
resultExit :: FixResult a -> ExitCode

-- | Parse External Qualifiers --------------------------------------------
parseFInfo :: [FilePath] -> IO (FInfo a)

module Language.Fixpoint.Solver.TrivialSort
nontrivsorts :: (Fixpoint a) => Config -> FInfo a -> IO (Result a)
instance GHC.Generics.Constructor Language.Fixpoint.Solver.TrivialSort.C1_2NTV
instance GHC.Generics.Constructor Language.Fixpoint.Solver.TrivialSort.C1_1NTV
instance GHC.Generics.Constructor Language.Fixpoint.Solver.TrivialSort.C1_0NTV
instance GHC.Generics.Datatype Language.Fixpoint.Solver.TrivialSort.D1NTV
instance GHC.Generics.Generic Language.Fixpoint.Solver.TrivialSort.NTV
instance GHC.Show.Show Language.Fixpoint.Solver.TrivialSort.NTV
instance GHC.Classes.Ord Language.Fixpoint.Solver.TrivialSort.NTV
instance GHC.Classes.Eq Language.Fixpoint.Solver.TrivialSort.NTV
instance Data.Hashable.Class.Hashable Language.Fixpoint.Solver.TrivialSort.NTV
